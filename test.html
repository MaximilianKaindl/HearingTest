<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hearing Test Quiz</title>
    <style>
        :root {
            --primary: #3b82f6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.12);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            line-height: 1.6;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            max-width: 56rem;
            margin: 0 auto;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: 1.5rem;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border: 1px solid var(--glass-border);
        }
        h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, #fff, #e3f2fd, #bbdefb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        h1::before { content: '🎧 '; -webkit-text-fill-color: initial; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; color: #e3f2fd; }
        h3 { font-size: 1.25rem; margin-bottom: 0.75rem; color: #f0f9ff; display: flex; align-items: center; gap: 0.5rem; }
        h4 { font-size: 1.1rem; margin-bottom: 0.75rem; color: #e0f2fe; }
        .card {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--glass-border);
            transition: transform 0.25s;
        }
        .card:hover { transform: translateY(-2px); }
        .card.success { border-left: 4px solid var(--success); }
        .card.info { border-left: 4px solid var(--primary); }
        .card.warning { border-left: 4px solid var(--warning); }
        .card.error { border-left: 4px solid var(--error); }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.25s;
            text-decoration: none;
            white-space: nowrap;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary {
            background: linear-gradient(90deg, var(--primary), #2563eb);
            color: white;
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3);
        }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4); }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover:not(:disabled) { background: rgba(255, 255, 255, 0.15); transform: translateY(-1px); }
        .btn-success {
            background: linear-gradient(45deg, var(--success), #059669);
            color: white;
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.3);
        }
        .btn.selected { background: var(--success); box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5); }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }
        .grid { display: grid; gap: 0.75rem; margin: 1rem 0; }
        .grid-auto { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        .grid-freq { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
        .grid-2 { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
        .form-control {
            background: rgba(255, 255, 255, 0.95);
            color: #1f2937;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            transition: all 0.15s;
            width: 100%;
        }
        .form-control:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .radio-group, .checkbox-group { display: flex; flex-wrap: wrap; gap: 1rem; margin: 1rem 0; }
        .radio-item, .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.75rem;
            border-radius: 0.75rem;
            transition: all 0.15s;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
        }
        .radio-item:hover, .checkbox-item:hover { background: rgba(255, 255, 255, 0.1); border-color: rgba(255, 255, 255, 0.2); }
        input[type="radio"], input[type="checkbox"] { accent-color: var(--primary); transform: scale(1.1); }
        .progress-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            height: 12px;
            overflow: hidden;
            margin: 1.5rem 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #2563eb);
            border-radius: 1rem;
            transition: width 0.6s;
        }
        .progress-text { text-align: center; margin-top: 0.5rem; font-weight: 500; font-size: 0.9rem; }
        .status-message {
            padding: 1rem;
            border-radius: 0.75rem;
            margin: 1rem 0;
            font-weight: 500;
            border-left: 4px solid;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .status-message.success { background: rgba(16, 185, 129, 0.15); border-color: var(--success); color: #a7f3d0; }
        .status-message.error { background: rgba(239, 68, 68, 0.15); border-color: var(--error); color: #fecaca; }
        .status-message.warning { background: rgba(245, 158, 11, 0.15); border-color: var(--warning); color: #fde68a; }
        .status-message.info { background: rgba(59, 130, 246, 0.15); border-color: var(--primary); color: #dbeafe; }
        .score-display {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
            margin: 1.5rem 0;
            border: 1px solid var(--glass-border);
        }
        .score-display .score { font-size: 2.5rem; font-weight: 700; color: var(--success); margin-bottom: 0.5rem; }
        .audio-controls { display: flex; gap: 0.75rem; justify-content: center; flex-wrap: wrap; margin: 1.5rem 0; }
        .file-upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.25s;
            background: rgba(255, 255, 255, 0.02);
        }
        .file-upload-area:hover { border-color: var(--primary); background: rgba(59, 130, 246, 0.05); }
        .file-upload-area.dragover { border-color: var(--primary); background: rgba(59, 130, 246, 0.1); transform: scale(1.02); }
        .waveform-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 0.75rem;
            margin: 1rem 0;
            overflow: hidden;
            position: relative;
            height: 120px;
        }
        .waveform-canvas { width: 100%; height: 100%; cursor: crosshair; }
        .selection-overlay {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid var(--primary);
            pointer-events: none;
        }
        .feedback {
            padding: 1.25rem;
            border-radius: 1rem;
            margin: 1.25rem 0;
            border-left: 4px solid;
            animation: slideIn 0.4s ease-out;
        }
        .feedback.correct { background: rgba(16, 185, 129, 0.15); border-color: var(--success); color: #a7f3d0; }
        .feedback.incorrect { background: rgba(239, 68, 68, 0.15); border-color: var(--error); color: #fecaca; }
        .feedback.partial { background: rgba(245, 158, 11, 0.15); border-color: var(--warning); color: #fde68a; }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.2);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .warning-box {
            background: linear-gradient(135deg, var(--warning), #d97706);
            color: white;
            padding: 1.25rem;
            border-radius: 1rem;
            margin: 1.5rem 0;
            text-align: center;
            font-weight: 600;
        }
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .text-sm { font-size: 0.875rem; }
        @media (max-width: 768px) {
            body { padding: 0.5rem; }
            .container { padding: 1.25rem; }
            h1 { font-size: 2rem; }
            .grid-auto, .grid-freq, .grid-2 { grid-template-columns: 1fr; }
            .radio-group, .checkbox-group { flex-direction: column; }
            .audio-controls { flex-direction: column; align-items: center; }
            .btn { width: 100%; justify-content: center; }
            .btn-small { width: auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hearing Test Quiz</h1>

        <div id="setup" class="setup-section">
            <div class="warning-box">
                ⚠️ Please set your volume to a comfortable level before starting! Use headphones for best results.
            </div>

            <div class="card success">
                <h3>🎯 How it works</h3>
                <p>You'll hear original audio, then filtered audio. Your task:</p>
                <ol style="margin-left: 1.25rem; margin-top: 0.5rem;">
                    <li>Identify the filter type: Lowpass, Highpass, Notch, or Bandpass</li>
                    <li>If it's Notch or Bandpass, also guess the center frequency from the options</li>
                </ol>
            </div>

            <div class="card info">
                <h3>🎵 Audio Source</h3>
                <div class="radio-group">
                    <label class="radio-item">
                        <input type="radio" name="audioSource" value="pink" checked>
                        <span>Use Pink Noise (Default)</span>
                    </label>
                    <label class="radio-item">
                        <input type="radio" name="audioSource" value="file">
                        <span>Upload Audio File (Select Segment)</span>
                    </label>
                    <label class="radio-item">
                        <input type="radio" name="audioSource" value="random">
                        <span>Upload Audio File (Random Segments)</span>
                    </label>
                </div>

                <div id="fileSection" class="hidden">
                    <div class="file-upload-area" onclick="document.getElementById('audioFile').click()">
                        <input type="file" id="audioFile" accept="audio/*" class="hidden">
                        <div style="margin-bottom: 0.5rem;">📁 Click to select audio file or drag and drop</div>
                        <small>Supported: MP3, WAV, OGG, M4A</small>
                    </div>
                    <div id="fileStatus" class="status-message hidden"></div>
                    
                    <div id="randomSegmentInfo" class="status-message info hidden">
                        <strong>Random Segment Mode:</strong> Each quiz question will use a different random <span id="randomDuration">3</span>-second segment from your uploaded file (resampled to 44100 Hz).
                    </div>
                    
                    <div id="segmentSelector" class="hidden">
                        <h4>🎯 Select Audio Segment</h4>
                        
                        <div class="audio-controls">
                            <button id="playFullAudio" class="btn btn-secondary btn-small">▶️ Play Full</button>
                            <button id="pauseAudio" class="btn btn-secondary btn-small">⏸️ Pause</button>
                            <button id="playSelection" class="btn btn-success btn-small" disabled>▶️ Play Selection</button>
                        </div>

                        <div class="waveform-container">
                            <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                            <div id="selectionOverlay" class="selection-overlay hidden"></div>
                        </div>

                        <div class="grid grid-2">
                            <div>
                                <label for="startTime" class="text-sm">Start Time (seconds)</label>
                                <input type="number" id="startTime" class="form-control" min="0" step="0.1" value="0">
                            </div>
                            <div>
                                <label for="endTime" class="text-sm">End Time (seconds)</label>
                                <input type="number" id="endTime" class="form-control" min="0" step="0.1" value="3">
                            </div>
                        </div>

                        <div class="text-center">
                            <button id="resetSelection" class="btn btn-secondary btn-small">🔄 Reset Selection</button>
                        </div>

                        <div class="status-message success text-center">
                            <strong>Selected Duration:</strong> <span id="selectedDuration">3.0</span> seconds<br>
                            <small>This selected duration will be used for the quiz!</small>
                        </div>
                    </div>
                </div>
            </div>

            <div id="durationSection" class="card info">
                <h3>⏱️ Audio Sample Duration</h3>
                <select id="sampleDuration" class="form-control">
                    <option value="1.0">1 second</option>
                    <option value="2.0">2 seconds</option>
                    <option value="3.0" selected>3 seconds (Default)</option>
                    <option value="5.0">5 seconds</option>
                </select>
                <div class="status-message info text-sm">
                    This duration will be used for pink noise or random segments from uploaded files.
                </div>
            </div>

            <div class="card info">
                <h3>🎛️ Filter Mode</h3>
                <div class="radio-group">
                    <label class="radio-item">
                        <input type="radio" name="filterMode" value="random" checked>
                        <span>Random Filter Types (All Types)</span>
                    </label>
                    <label class="radio-item">
                        <input type="radio" name="filterMode" value="fixed">
                        <span>Focus Mode (Notch/Bandpass Only)</span>
                    </label>
                </div>

                <div id="fixedFilterSection" class="hidden">
                    <select id="fixedFilterType" class="form-control">
                        <option value="Notch">Notch Filter</option>
                        <option value="Bandpass">Bandpass Filter</option>
                    </select>
                    <div class="status-message warning">
                        <strong>Focus Mode:</strong> The filter type is fixed to <strong><span id="filterTypeDisplay">Notch</span></strong>.
                        You'll only need to identify the center frequency.
                    </div>
                </div>
            </div>

            <div id="exampleSection" class="card info">
                <h3>🔊 Hear Filter Examples</h3>
                <p>Select a filter type and frequency to hear what the filtered audio sounds like.</p>

                <h4>Filter Type</h4>
                <div class="grid grid-auto" id="exampleFilterTypes">
                    <button class="btn btn-secondary" data-type="Lowpass">Lowpass</button>
                    <button class="btn btn-secondary" data-type="Highpass">Highpass</button>
                    <button class="btn btn-secondary" data-type="Notch">Notch</button>
                    <button class="btn btn-secondary" data-type="Bandpass">Bandpass</button>
                </div>

                <div id="exampleFrequencySection" class="hidden">
                    <h4>Center Frequency</h4>
                    <div class="grid grid-freq" id="exampleFrequencies">
                        <button class="btn btn-secondary" data-freq="100">100 Hz (Low)</button>
                        <button class="btn btn-secondary" data-freq="600">600 Hz (Mid-Low)</button>
                        <button class="btn btn-secondary" data-freq="1500">1500 Hz (Mid)</button>
                        <button class="btn btn-secondary" data-freq="5000">5000 Hz (Mid-High)</button>
                        <button class="btn btn-secondary" data-freq="8000">8000 Hz (High)</button>
                        <button class="btn btn-secondary" data-freq="10000">10000 Hz (Very High)</button>
                    </div>
                </div>

                <div class="audio-controls">
                    <button id="playExampleOriginal" class="btn btn-primary" disabled>▶️ Play Original</button>
                    <button id="playExampleFiltered" class="btn btn-primary" disabled>▶️ Play Filtered</button>
                </div>
                <div id="exampleStatus" class="status-message hidden"></div>
                <div class="status-message info text-sm text-center">
                    Audio source: <span id="exampleAudioSource">Pink Noise</span> | Duration: <span id="exampleDuration">3</span> seconds<br>
                    <span id="exampleSourceNote">Using the audio sample duration setting</span>
                </div>
            </div>

            <div class="card success">
                <h3>📊 Scoring</h3>
                <ul style="margin-left: 1.25rem;">
                    <li><strong>Random Mode - Lowpass/Highpass:</strong> 1 point for correct type</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 1 point for correct type AND correct frequency</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 0.5 points for correct type but wrong frequency</li>
                    <li><strong>Focus Mode:</strong> 1 point for correct frequency (filter type is given)</li>
                </ul>
            </div>

            <div class="card info">
                <h3>⚙️ Options</h3>
                <div class="checkbox-group">
                    <label class="checkbox-item">
                        <input type="checkbox" id="showTypeAnswers">
                        <span>Show correct filter type if your guess is wrong (in Random mode)</span>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="showDetails">
                        <span>Show filter details (parameters) after each guess</span>
                    </label>
                </div>
            </div>

            <div class="text-center">
                <button id="startButton" class="btn btn-primary">🚀 Start Quiz (10 Questions)</button>
            </div>
        </div>

        <div id="quiz" class="hidden">
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div class="progress-text">Question <span id="questionNum">1</span>/10</div>

            <div class="score-display">
                <div class="score"><span id="currentScore">0</span>/10</div>
                <div class="text-sm">Current Score</div>
            </div>

            <div class="card">
                <h3 id="questionTitle">Question 1</h3>

                <div id="playSection" class="audio-controls">
                    <button id="playOriginal" class="btn btn-primary">▶️ Play Original</button>
                    <button id="playFiltered" class="btn btn-primary">▶️ Play Filtered</button>
                </div>
                <div id="audioStatus" class="status-message hidden"></div>

                <div id="guessSection">
                    <div id="filterTypeSection">
                        <h4>What type of filter was applied?</h4>
                        <div class="grid grid-auto" id="filterTypes">
                            <button class="btn btn-secondary" data-type="Lowpass">Lowpass</button>
                            <button class="btn btn-secondary" data-type="Highpass">Highpass</button>
                            <button class="btn btn-secondary" data-type="Notch">Notch</button>
                            <button class="btn btn-secondary" data-type="Bandpass">Bandpass</button>
                        </div>
                    </div>

                    <div id="frequencySection" class="hidden">
                        <h4>What's the center frequency?</h4>
                        <div class="grid grid-freq" id="frequencies">
                            <button class="btn btn-secondary" data-freq="100">100 Hz (Low)</button>
                            <button class="btn btn-secondary" data-freq="600">600 Hz (Mid-Low)</button>
                            <button class="btn btn-secondary" data-freq="1500">1500 Hz (Mid)</button>
                            <button class="btn btn-secondary" data-freq="5000">5000 Hz (Mid-High)</button>
                            <button class="btn btn-secondary" data-freq="8000">8000 Hz (High)</button>
                            <button class="btn btn-secondary" data-freq="10000">10000 Hz (Very High)</button>
                        </div>
                    </div>

                    <div id="focusModeInfo" class="hidden status-message warning">
                        Filter type: <strong><span id="givenFilterType"></span></strong> - Just identify the frequency!
                    </div>

                    <div class="text-center">
                        <button id="submitAnswer" class="btn btn-primary" disabled>Submit Answer</button>
                    </div>
                </div>

                <div id="feedback" class="feedback hidden"></div>
                <div class="text-center">
                    <button id="nextQuestion" class="btn btn-primary hidden">Next Question</button>
                </div>
            </div>
        </div>

        <div id="results" class="hidden">
            <div class="score-display">
                <h2>🎉 Quiz Complete!</h2>
                <div id="finalScore"></div>
            </div>
            <div id="performanceAnalysis"></div>
            <div class="text-center">
                <button id="restartButton" class="btn btn-primary">🔄 Take Quiz Again</button>
            </div>
        </div>
    </div>

    <script>
        class HearingTestQuiz {
            constructor() {
                this.audioContext = null;
                this.currentSourceNode = null;
                this.customAudioBuffer = null;
                this.selectedAudioSegment = null;
                this.segmentStartTime = 0;
                this.segmentEndTime = 3;
                
                this.currentQuestion = 0;
                this.score = 0;
                this.questions = [];
                this.questionResults = [];
                this.selectedFilterType = null;
                this.selectedFrequency = null;
                
                this.settings = {
                    showTypeAnswers: false, showDetails: false, useCustomAudio: false,
                    useRandomSegments: false, useFixedFilter: false, fixedFilterType: 'Notch',
                    userDuration: 3.0, audioSourceValue: 'pink'
                };
                
                this.exampleSelectedFilterType = null;
                this.exampleSelectedFrequency = null;
                this.exampleOriginalAudioData = null;
                
                this.NUM_QUESTIONS = 10;
                this.FILTER_TYPES = ["Lowpass", "Highpass", "Notch", "Bandpass"];
                this.NOTCH_BAND_CHOICES = { 100: "Low", 600: "Mid-Low", 1500: "Mid", 5000: "Mid-High", 8000: "High", 10000: "Very High" };
                this.NOTCH_BAND_FREQ_LIST = [100, 600, 1500, 5000, 8000, 10000];
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setupFileUpload();
                this.setupSegmentSelector();
                this.updateUI();
            }

            async initAudioContext() {
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.audioContext.state === 'suspended') await this.audioContext.resume();
                return this.audioContext;
            }

            generatePinkNoise(duration, sampleRate = 44100) {
                // Ensure minimum duration
                const safeDuration = Math.max(duration || 1.0, 0.1);
                const samples = Math.max(Math.floor(safeDuration * sampleRate), 1);
                const nSources = 16;
                const maxVal = 1.0 / nSources;
                const sources = new Array(nSources).fill(0);
                const pink = new Float32Array(samples);
                let acc = 0.0;

                for (let i = 0; i < samples; i++) {
                    let changed = (i + 1) & -(i + 1);
                    let k = 0;
                    if (changed !== 0) {
                        let temp = changed;
                        while (temp > 1) { temp >>= 1; k++; }
                    }
                    const idxToChange = k % nSources;
                    if (changed === (1 << k)) {
                        acc -= sources[idxToChange];
                        const newVal = (Math.random() - 0.5) * 2 * maxVal;
                        sources[idxToChange] = newVal;
                        acc += newVal;
                    }
                    pink[i] = acc;
                }

                const mean = pink.reduce((sum, val) => sum + val, 0) / pink.length;
                let maxAbs = 0;
                for (let i = 0; i < samples; i++) {
                    pink[i] = pink[i] - mean;
                    maxAbs = Math.max(maxAbs, Math.abs(pink[i]));
                }
                if (maxAbs > 1e-6) {
                    const gain = 0.4 / maxAbs;
                    for (let i = 0; i < samples; i++) pink[i] *= gain;
                }
                return pink;
            }

            async applyFilter(audioData, filterType, frequency, duration) {
                const context = await this.initAudioContext();
                
                // Validate inputs
                if (!audioData || audioData.length === 0) {
                    throw new Error('Invalid audio data provided');
                }
                if (!duration || duration <= 0) {
                    throw new Error('Invalid duration provided');
                }
                
                // Ensure minimum duration and buffer length
                const safeDuration = Math.max(duration, 0.1);
                const bufferLength = Math.max(Math.floor(safeDuration * 44100), 1);
                const dataToUse = new Float32Array(bufferLength);
                
                // Handle case where audioData is shorter than needed
                if (audioData.length >= bufferLength) {
                    dataToUse.set(audioData.slice(0, bufferLength));
                } else {
                    // Repeat the audio data if it's too short
                    for (let i = 0; i < bufferLength; i++) {
                        dataToUse[i] = audioData[i % audioData.length];
                    }
                }

                const offlineContext = new OfflineAudioContext(1, bufferLength, 44100);
                const source = offlineContext.createBufferSource();
                const audioBuffer = offlineContext.createBuffer(1, bufferLength, 44100);
                audioBuffer.getChannelData(0).set(dataToUse);
                source.buffer = audioBuffer;

                const filter = offlineContext.createBiquadFilter();
                this.configureFilter(filter, filterType, frequency);
                source.connect(filter);
                filter.connect(offlineContext.destination);
                source.start();

                return await offlineContext.startRendering();
            }

            configureFilter(filter, filterType, frequency) {
                const LOWPASS_FREQ = 5000, HIGHPASS_FREQ = 150, PEAK_EQ_GAIN_DB = 9.0, PEAK_EQ_BW_OCT = 1.6;
                switch (filterType) {
                    case 'Lowpass':
                        filter.type = 'lowpass';
                        filter.frequency.value = LOWPASS_FREQ;
                        filter.Q.value = Math.SQRT1_2;
                        break;
                    case 'Highpass':
                        filter.type = 'highpass';
                        filter.frequency.value = HIGHPASS_FREQ;
                        filter.Q.value = Math.SQRT1_2;
                        break;
                    case 'Notch':
                        filter.type = 'peaking';
                        filter.frequency.value = frequency;
                        filter.gain.value = -PEAK_EQ_GAIN_DB;
                        filter.Q.value = frequency / (frequency * (Math.pow(2, PEAK_EQ_BW_OCT / 2) - Math.pow(2, -PEAK_EQ_BW_OCT / 2)));
                        break;
                    case 'Bandpass':
                        filter.type = 'peaking';
                        filter.frequency.value = frequency;
                        filter.gain.value = PEAK_EQ_GAIN_DB;
                        filter.Q.value = frequency / (frequency * (Math.pow(2, PEAK_EQ_BW_OCT / 2) - Math.pow(2, -PEAK_EQ_BW_OCT / 2)));
                        break;
                }
            }

            async stopCurrentAudio() {
                if (this.currentSourceNode && this.currentSourceNode.context.state === 'running') {
                    try { this.currentSourceNode.stop(); } catch (e) { console.warn("Error stopping audio:", e); }
                    this.currentSourceNode = null;
                }
            }

            async playAudioBuffer(audioBuffer, startTime = 0, duration = null) {
                const context = await this.initAudioContext();
                await this.stopCurrentAudio();
                const source = context.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(context.destination);
                this.currentSourceNode = source;
                if (duration !== null) source.start(0, startTime, duration);
                else source.start(0, startTime);
                return new Promise(resolve => {
                    source.onended = () => { source.disconnect(); if (this.currentSourceNode === source) this.currentSourceNode = null; resolve(); };
                    source.onerror = () => { if (this.currentSourceNode === source) this.currentSourceNode = null; resolve(); };
                });
            }

            async playAudioData(audioData, sampleRate = 44100) {
                const context = await this.initAudioContext();
                const tempBuffer = context.createBuffer(1, audioData.length, sampleRate);
                tempBuffer.getChannelData(0).set(audioData);
                await this.playAudioBuffer(tempBuffer);
            }

            show(id) { document.getElementById(id).classList.remove('hidden'); }
            hide(id) { document.getElementById(id).classList.add('hidden'); }
            setText(id, text) { document.getElementById(id).textContent = text; }
            setHTML(id, html) { document.getElementById(id).innerHTML = html; }

            showStatus(id, message, type = 'info', duration = 0) {
                const el = document.getElementById(id);
                if (!el) return;
                el.className = `status-message ${type}`;
                el.innerHTML = message;
                el.classList.remove('hidden');
                if (duration > 0) setTimeout(() => el.classList.add('hidden'), duration);
            }

            updateButtonSelection(containerSelector, dataAttribute, value) {
                document.querySelectorAll(`${containerSelector} .btn`).forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.getAttribute(dataAttribute) === value) btn.classList.add('selected');
                });
            }

            clearButtonSelections(containerSelector) {
                document.querySelectorAll(`${containerSelector} .btn`).forEach(btn => btn.classList.remove('selected'));
            }

            setButtonsDisabled(selector, disabled) {
                document.querySelectorAll(selector).forEach(btn => btn.disabled = disabled);
            }

            setupEventListeners() {
                document.getElementById('sampleDuration').addEventListener('change', () => this.onDurationChange());
                document.querySelectorAll('input[name="audioSource"]').forEach(input => 
                    input.addEventListener('change', () => this.onAudioSourceChange()));
                document.querySelectorAll('input[name="filterMode"]').forEach(input => 
                    input.addEventListener('change', () => this.onFilterModeChange()));
                document.getElementById('fixedFilterType').addEventListener('change', () => this.onFixedFilterTypeChange());
                document.getElementById('audioFile').addEventListener('change', () => this.handleAudioFile());
                document.getElementById('startButton').addEventListener('click', () => this.startQuiz());

                document.querySelectorAll('#exampleFilterTypes .btn').forEach(btn => 
                    btn.addEventListener('click', (e) => this.selectExampleFilterType(e.target.dataset.type)));
                document.querySelectorAll('#exampleFrequencies .btn').forEach(btn => 
                    btn.addEventListener('click', (e) => this.selectExampleFrequency(parseInt(e.target.dataset.freq))));
                document.getElementById('playExampleOriginal').addEventListener('click', () => this.playExampleOriginal());
                document.getElementById('playExampleFiltered').addEventListener('click', () => this.playExampleFiltered());

                document.getElementById('playOriginal').addEventListener('click', () => this.playOriginal());
                document.getElementById('playFiltered').addEventListener('click', () => this.playFiltered());
                document.querySelectorAll('#filterTypes .btn').forEach(btn => 
                    btn.addEventListener('click', (e) => this.selectFilterType(e.target.dataset.type)));
                document.querySelectorAll('#frequencies .btn').forEach(btn => 
                    btn.addEventListener('click', (e) => this.selectFrequency(parseInt(e.target.dataset.freq))));
                document.getElementById('submitAnswer').addEventListener('click', () => this.submitAnswer());
                document.getElementById('nextQuestion').addEventListener('click', () => this.nextQuestion());
                document.getElementById('restartButton').addEventListener('click', () => this.restartQuiz());

                document.getElementById('playFullAudio').addEventListener('click', () => this.playFullAudio());
                document.getElementById('pauseAudio').addEventListener('click', () => this.pauseAudio());
                document.getElementById('playSelection').addEventListener('click', () => this.playSelectedSegment());
                document.getElementById('resetSelection').addEventListener('click', () => this.resetSelection());
                document.getElementById('startTime').addEventListener('input', () => this.updateSelectionFromInputs());
                document.getElementById('endTime').addEventListener('input', () => this.updateSelectionFromInputs());
            }

            setupFileUpload() {
                const uploadArea = document.querySelector('.file-upload-area');
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); });
                });
                ['dragenter', 'dragover'].forEach(eventName => 
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover')));
                ['dragleave', 'drop'].forEach(eventName => 
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover')));
                uploadArea.addEventListener('drop', (e) => {
                    if (e.dataTransfer.files.length > 0) {
                        document.getElementById('audioFile').files = e.dataTransfer.files;
                        this.handleAudioFile();
                    }
                });
            }

            setupSegmentSelector() {
                const canvas = document.getElementById('waveformCanvas');
                canvas.addEventListener('mousedown', (e) => this.startWaveformSelection(e));
                canvas.addEventListener('mousemove', (e) => this.updateWaveformSelection(e));
                canvas.addEventListener('mouseup', () => this.endWaveformSelection());
            }

            onDurationChange() {
                const selectedDuration = Math.max(parseFloat(document.getElementById('sampleDuration').value) || 3.0, 0.1);
                if (this.settings.useRandomSegments || !this.settings.useCustomAudio || !this.selectedAudioSegment) {
                    this.settings.userDuration = selectedDuration;
                }
                if (this.settings.useRandomSegments) this.setText('randomDuration', selectedDuration);
                this.setText('exampleDuration', this.settings.userDuration);
                this.prepareExampleAudio();
                this.updateExamplePlayButtonState();
            }

            onAudioSourceChange() {
                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                this.settings.useCustomAudio = audioSourceValue === 'file' || audioSourceValue === 'random';
                this.settings.useRandomSegments = audioSourceValue === 'random';

                if (this.settings.useCustomAudio) {
                    this.show('fileSection');
                    if (this.settings.useRandomSegments) {
                        this.hide('segmentSelector'); this.show('randomSegmentInfo'); this.show('durationSection');
                        document.getElementById('startButton').disabled = !this.customAudioBuffer;
                        this.setText('randomDuration', parseFloat(document.getElementById('sampleDuration').value));
                        this.settings.userDuration = parseFloat(document.getElementById('sampleDuration').value);
                    } else {
                        this.hide('randomSegmentInfo'); this.hide('durationSection');
                        document.getElementById('startButton').disabled = !this.selectedAudioSegment;
                    }
                } else {
                    this.hide('fileSection'); this.hide('segmentSelector'); this.hide('randomSegmentInfo');
                    this.show('durationSection'); this.hide('fileStatus');
                    document.getElementById('startButton').disabled = false;
                    this.settings.userDuration = parseFloat(document.getElementById('sampleDuration').value);
                }
                this.prepareExampleAudio(); this.updateExamplePlayButtonState();
            }

            onFilterModeChange() {
                this.settings.useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';
                if (this.settings.useFixedFilter) {
                    this.show('fixedFilterSection');
                    this.settings.fixedFilterType = document.getElementById('fixedFilterType').value;
                    this.setText('filterTypeDisplay', this.settings.fixedFilterType);
                } else {
                    this.hide('fixedFilterSection');
                    this.settings.fixedFilterType = null;
                }
            }

            onFixedFilterTypeChange() {
                this.settings.fixedFilterType = document.getElementById('fixedFilterType').value;
                this.setText('filterTypeDisplay', this.settings.fixedFilterType);
            }

            async processAudioFile(file) {
                const context = await this.initAudioContext();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const originalBuffer = await context.decodeAudioData(e.target.result);
                            const durationInSeconds = originalBuffer.duration;
                            const resampledLength = Math.floor(durationInSeconds * 44100);
                            const offlineContext = new OfflineAudioContext(originalBuffer.numberOfChannels, resampledLength, 44100);
                            const source = offlineContext.createBufferSource();
                            source.buffer = originalBuffer;
                            source.connect(offlineContext.destination);
                            source.start();
                            const resampledBuffer = await offlineContext.startRendering();

                            if (resampledBuffer.numberOfChannels > 1) {
                                const monoBuffer = context.createBuffer(1, resampledBuffer.length, 44100);
                                monoBuffer.getChannelData(0).set(resampledBuffer.getChannelData(0));
                                this.customAudioBuffer = monoBuffer;
                            } else {
                                this.customAudioBuffer = resampledBuffer;
                            }
                            resolve(this.customAudioBuffer);
                        } catch (error) { reject(error); }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            async handleAudioFile() {
                const fileInput = document.getElementById('audioFile');
                const file = fileInput.files[0];
                const startButton = document.getElementById('startButton');

                this.hide('fileStatus');
                this.customAudioBuffer = null;
                this.selectedAudioSegment = null;
                startButton.disabled = true;
                this.hide('segmentSelector');
                this.updateExamplePlayButtonState();

                if (!file) { this.updateExamplePlayButtonState(); return; }

                try {
                    const audioBuffer = await this.processAudioFile(file);
                    if (audioBuffer.duration < 0.5) {
                        this.showStatus('fileStatus', 
                            `File is too short (${audioBuffer.duration.toFixed(2)}s). Please select a file at least 0.5 seconds long.`, 'error');
                        this.customAudioBuffer = null;
                    } else {
                        this.showStatus('fileStatus', `✅ File loaded successfully! Duration: ${audioBuffer.duration.toFixed(2)}s`, 'success');
                        const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                        if (audioSourceValue === 'file') {
                            this.show('segmentSelector');
                            this.segmentStartTime = 0;
                            const defaultDuration = parseFloat(document.getElementById('sampleDuration').value);
                            this.segmentEndTime = Math.min(defaultDuration, audioBuffer.duration);
                            this.updateSelectionFromTimes();
                            this.generateWaveform();
                            startButton.disabled = false;
                        } else if (audioSourceValue === 'random') {
                            startButton.disabled = false;
                        }
                    }
                    this.updateExamplePlayButtonState();
                } catch (error) {
                    console.error("Error processing audio file:", error);
                    this.showStatus('fileStatus', `Error processing audio file: ${error.message}`, 'error');
                    this.customAudioBuffer = null;
                    this.updateExamplePlayButtonState();
                }
            }

            generateWaveform() {
                if (!this.customAudioBuffer) return;
                const canvas = document.getElementById('waveformCanvas');
                const ctx = canvas.getContext('2d');
                const audioData = this.customAudioBuffer.getChannelData(0);
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                const width = rect.width, height = rect.height;
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                const step = Math.floor(audioData.length / width);
                const centerY = height / 2;
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const start = i * step;
                    const end = Math.min(start + step, audioData.length);
                    let min = 0, max = 0;
                    for (let j = start; j < end; j++) {
                        min = Math.min(min, audioData[j]);
                        max = Math.max(max, audioData[j]);
                    }
                    const minY = centerY + (min * centerY * 0.8);
                    const maxY = centerY + (max * centerY * 0.8);
                    ctx.moveTo(i, minY);
                    ctx.lineTo(i, maxY);
                }
                ctx.stroke();
                this.waveformData = { width, audioLength: audioData.length };
            }

            updateSelectionOverlay() {
                if (!this.customAudioBuffer || !this.waveformData) return;
                const overlay = document.getElementById('selectionOverlay');
                const duration = this.customAudioBuffer.duration;
                const startPercent = (this.segmentStartTime / duration) * 100;
                const endPercent = (this.segmentEndTime / duration) * 100;
                const widthPercent = endPercent - startPercent;
                overlay.style.left = `${startPercent}%`;
                overlay.style.width = `${widthPercent}%`;
                overlay.classList.remove('hidden');
            }

            extractSelectedSegment() {
                if (!this.customAudioBuffer) return;
                const startSample = Math.floor(this.segmentStartTime * 44100);
                const endSample = Math.floor(this.segmentEndTime * 44100);
                const segmentLength = endSample - startSample;
                if (segmentLength > 0) {
                    const audioData = this.customAudioBuffer.getChannelData(0);
                    this.selectedAudioSegment = audioData.slice(startSample, endSample);
                }
            }

            getRandomSegment(duration) {
                if (!this.customAudioBuffer) return null;
                
                // Ensure minimum duration
                const safeDuration = Math.max(duration || 1.0, 0.1);
                const numSamples = Math.max(Math.floor(safeDuration * 44100), 1);
                const maxStartSample = Math.max(0, this.customAudioBuffer.length - numSamples);
                const startSample = Math.floor(Math.random() * (maxStartSample + 1));
                const endSample = Math.min(startSample + numSamples, this.customAudioBuffer.length);
                
                let originalData = this.customAudioBuffer.getChannelData(0).slice(startSample, endSample);
                if (originalData.length < numSamples) {
                    const paddedData = new Float32Array(numSamples);
                    if (originalData.length > 0) {
                        // Repeat the audio data to fill the required length
                        for (let i = 0; i < numSamples; i++) {
                            paddedData[i] = originalData[i % originalData.length];
                        }
                    }
                    originalData = paddedData;
                }
                return originalData;
            }

            startWaveformSelection(e) {
                if (!this.customAudioBuffer) return;
                this.isSelecting = true;
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                const time = percent * this.customAudioBuffer.duration;
                this.segmentStartTime = Math.max(0, time);
                this.updateSelectionFromTimes();
            }

            updateWaveformSelection(e) {
                if (!this.isSelecting || !this.customAudioBuffer) return;
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                const time = percent * this.customAudioBuffer.duration;
                this.segmentEndTime = Math.min(this.customAudioBuffer.duration, Math.max(this.segmentStartTime + 0.1, time));
                this.updateSelectionFromTimes();
            }

            endWaveformSelection() { this.isSelecting = false; }

            updateSelectionFromInputs() {
                const startTime = parseFloat(document.getElementById('startTime').value) || 0;
                const endTime = parseFloat(document.getElementById('endTime').value) || 0;
                if (this.customAudioBuffer) {
                    this.segmentStartTime = Math.max(0, Math.min(startTime, this.customAudioBuffer.duration));
                    this.segmentEndTime = Math.max(this.segmentStartTime + 0.1, Math.min(endTime, this.customAudioBuffer.duration));
                } else {
                    this.segmentStartTime = Math.max(0, startTime);
                    this.segmentEndTime = Math.max(this.segmentStartTime + 0.1, endTime);
                }
                this.updateSelectionFromTimes();
            }

            updateSelectionFromTimes() {
                document.getElementById('startTime').value = this.segmentStartTime.toFixed(1);
                document.getElementById('endTime').value = this.segmentEndTime.toFixed(1);
                const duration = this.segmentEndTime - this.segmentStartTime;
                this.setText('selectedDuration', duration.toFixed(1));
                document.getElementById('playSelection').disabled = duration < 0.1;
                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                if (audioSourceValue === 'file') this.settings.userDuration = duration;
                this.updateSelectionOverlay();
                this.extractSelectedSegment();
                this.updateExamplePlayButtonState();
            }

            resetSelection() {
                if (this.customAudioBuffer) {
                    this.segmentStartTime = 0;
                    const defaultDuration = parseFloat(document.getElementById('sampleDuration').value);
                    this.segmentEndTime = Math.min(defaultDuration, this.customAudioBuffer.duration);
                } else {
                    this.segmentStartTime = 0;
                    this.segmentEndTime = parseFloat(document.getElementById('sampleDuration').value);
                }
                this.updateSelectionFromTimes();
            }

            async playFullAudio() {
                if (!this.customAudioBuffer) return;
                await this.playAudioBuffer(this.customAudioBuffer);
            }

            async playSelectedSegment() {
                if (!this.customAudioBuffer || !this.selectedAudioSegment) return;
                const duration = this.segmentEndTime - this.segmentStartTime;
                await this.playAudioBuffer(this.customAudioBuffer, this.segmentStartTime, duration);
            }

            async pauseAudio() { await this.stopCurrentAudio(); }

            generateQuestion() {
                let filterType, frequency, label, details;
                if (this.settings.useFixedFilter) {
                    filterType = this.settings.fixedFilterType;
                    frequency = this.NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * this.NOTCH_BAND_FREQ_LIST.length)];
                    label = this.NOTCH_BAND_CHOICES[frequency];
                } else {
                    filterType = this.FILTER_TYPES[Math.floor(Math.random() * this.FILTER_TYPES.length)];
                }

                switch (filterType) {
                    case 'Lowpass':
                        frequency = 5000; label = 'Lowpass';
                        details = `Lowpass Filter (Cutoff: 5000 Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                        break;
                    case 'Highpass':
                        frequency = 150; label = 'Highpass';
                        details = `Highpass Filter (Cutoff: 150 Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                        break;
                    case 'Notch':
                    case 'Bandpass':
                        if (!this.settings.useFixedFilter) {
                            frequency = this.NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * this.NOTCH_BAND_FREQ_LIST.length)];
                            label = this.NOTCH_BAND_CHOICES[frequency];
                        } else {
                            label = this.NOTCH_BAND_CHOICES[frequency];
                        }
                        const gain = filterType === 'Notch' ? -9.0 : 9.0;
                        const calculatedQ = frequency / (frequency * (Math.pow(2, 1.6 / 2) - Math.pow(2, -1.6 / 2)));
                        details = `${filterType} Filter (Center: ${frequency} Hz (${label}), BW: 1.6 Oct, Gain: ${gain > 0 ? '+' : ''}${gain} dB, Q: ${calculatedQ.toFixed(2)})`;
                        break;
                }

                // Ensure duration is valid
                const safeDuration = Math.max(this.settings.userDuration || 3.0, 0.1);
                let originalAudioData;

                if (this.settings.useCustomAudio && this.settings.useRandomSegments && this.customAudioBuffer) {
                    originalAudioData = this.getRandomSegment(safeDuration);
                } else if (this.settings.useCustomAudio && !this.settings.useRandomSegments && this.selectedAudioSegment) {
                    const numSamples = Math.floor(safeDuration * 44100);
                    if (this.selectedAudioSegment.length >= numSamples) {
                        originalAudioData = this.selectedAudioSegment.slice(0, numSamples);
                    } else {
                        originalAudioData = new Float32Array(numSamples);
                        let sourceIndex = 0;
                        for (let i = 0; i < numSamples; i++) {
                            originalAudioData[i] = this.selectedAudioSegment[sourceIndex % this.selectedAudioSegment.length];
                            sourceIndex++;
                        }
                    }
                } else {
                    originalAudioData = this.generatePinkNoise(safeDuration);
                }

                // Validate that we have valid audio data
                if (!originalAudioData || originalAudioData.length === 0) {
                    console.warn('Generated empty audio data, using fallback pink noise');
                    originalAudioData = this.generatePinkNoise(safeDuration);
                }

                return { filterType, frequency, label, details, originalAudio: originalAudioData, filteredAudio: null };
            }

            saveCurrentSettings() {
                this.settings.showTypeAnswers = document.getElementById('showTypeAnswers').checked;
                this.settings.showDetails = document.getElementById('showDetails').checked;
                this.settings.audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
            }

            restoreSettings() {
                document.getElementById('showTypeAnswers').checked = this.settings.showTypeAnswers;
                document.getElementById('showDetails').checked = this.settings.showDetails;
                document.querySelector(`input[name="audioSource"][value="${this.settings.audioSourceValue}"]`).checked = true;
                document.getElementById('sampleDuration').value = this.settings.userDuration.toString();
                document.querySelector(`input[name="filterMode"][value="${this.settings.useFixedFilter ? 'fixed' : 'random'}"]`).checked = true;
                document.getElementById('fixedFilterType').value = this.settings.fixedFilterType;
                this.onAudioSourceChange();
                this.onFilterModeChange();
                this.onDurationChange();
            }

            async startQuiz() {
                await this.stopCurrentAudio();
                this.saveCurrentSettings();
                
                // Ensure valid duration
                this.settings.userDuration = Math.max(parseFloat(document.getElementById('sampleDuration').value) || 3.0, 0.1);

                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                this.settings.useCustomAudio = audioSourceValue === 'file' || audioSourceValue === 'random';
                this.settings.useRandomSegments = audioSourceValue === 'random';
                this.settings.useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';

                if (this.settings.useFixedFilter) this.settings.fixedFilterType = document.getElementById('fixedFilterType').value;

                if (this.settings.useCustomAudio) {
                    if (!this.customAudioBuffer) {
                        this.showStatus('audioStatus', 'Please upload an audio file first.', 'error');
                        return;
                    }
                    if (this.settings.useRandomSegments) {
                        const requiredSamples = Math.floor(this.settings.userDuration * 44100);
                        if (this.customAudioBuffer.length < requiredSamples) {
                            this.showStatus('audioStatus', 
                                `Uploaded file is too short for ${this.settings.userDuration}-second segments. Please select a longer file or reduce the duration.`, 'error');
                            return;
                        }
                    } else {
                        if (!this.selectedAudioSegment) {
                            this.showStatus('audioStatus', 'Please select an audio segment first.', 'error');
                            return;
                        }
                        const selectedDuration = this.segmentEndTime - this.segmentStartTime;
                        if (selectedDuration < 0.1) {
                            this.showStatus('audioStatus', 'Selected segment is too short. Please select at least 0.1 seconds.', 'error');
                            return;
                        }
                    }
                }

                this.questions = [];
                this.questionResults = [];
                for (let i = 0; i < this.NUM_QUESTIONS; i++) this.questions.push(this.generateQuestion());
                this.currentQuestion = 0;
                this.score = 0;
                this.hide('setup');
                this.show('quiz');
                await this.loadQuestion();
            }

            async loadQuestion() {
                const question = this.questions[this.currentQuestion];
                await this.stopCurrentAudio();
                this.resetQuestionUI();
                this.updateQuestionDisplay();
                this.configureQuestionMode();
                this.showStatus('audioStatus', '<div class="loading-spinner"></div>Loading audio...', 'info');
                this.setButtonsDisabled('#playSection button', true);

                try {
                    // Validate question data
                    if (!question.originalAudio || question.originalAudio.length === 0) {
                        throw new Error('Invalid original audio data');
                    }
                    
                    // Ensure safe duration
                    const safeDuration = Math.max(this.settings.userDuration || 3.0, 0.1);
                    
                    question.filteredAudio = await this.applyFilter(
                        question.originalAudio, 
                        question.filterType, 
                        question.frequency, 
                        safeDuration
                    );
                    
                    this.hide('audioStatus');
                    this.setButtonsDisabled('#playSection button', false);
                } catch (e) {
                    console.error("Failed to render filtered audio:", e);
                    this.showStatus('audioStatus', `Error generating audio: ${e.message}`, 'error');
                    this.showFeedback("Error generating audio for this question. Skipping.", 'incorrect');
                    this.show('nextQuestion');
                    this.hide('guessSection');
                }
            }

            resetQuestionUI() {
                this.hide('feedback');
                this.hide('nextQuestion');
                document.getElementById('submitAnswer').disabled = true;
                this.show('playSection');
                this.show('guessSection');
                this.selectedFilterType = null;
                this.selectedFrequency = null;
                this.clearButtonSelections('#filterTypes');
                this.clearButtonSelections('#frequencies');
            }

            updateQuestionDisplay() {
                const questionNum = this.currentQuestion + 1;
                this.setText('questionNum', questionNum);
                this.setText('questionTitle', `Question ${questionNum}`);
                this.setText('currentScore', this.score.toFixed(1));
                document.getElementById('progressBar').style.width = `${(this.currentQuestion / this.NUM_QUESTIONS) * 100}%`;
            }

            configureQuestionMode() {
                const question = this.questions[this.currentQuestion];
                if (this.settings.useFixedFilter) {
                    this.hide('filterTypeSection');
                    this.show('frequencySection');
                    this.show('focusModeInfo');
                    this.setText('givenFilterType', question.filterType);
                    this.selectedFilterType = question.filterType;
                } else {
                    this.show('filterTypeSection');
                    this.hide('frequencySection');
                    this.hide('focusModeInfo');
                    this.selectedFilterType = null;
                }
            }

            async playOriginal() {
                const question = this.questions[this.currentQuestion];
                await this.playAudioData(question.originalAudio);
            }

            async playFiltered() {
                const question = this.questions[this.currentQuestion];
                if (question.filteredAudio) await this.playAudioBuffer(question.filteredAudio);
            }

            selectFilterType(type) {
                this.selectedFilterType = type;
                this.updateButtonSelection('#filterTypes', 'data-type', type);
                if (type === 'Notch' || type === 'Bandpass') {
                    this.show('frequencySection');
                    this.selectedFrequency = null;
                    this.clearButtonSelections('#frequencies');
                    document.getElementById('submitAnswer').disabled = true;
                } else {
                    this.hide('frequencySection');
                    this.selectedFrequency = null;
                    this.clearButtonSelections('#frequencies');
                    document.getElementById('submitAnswer').disabled = false;
                }
            }

            selectFrequency(freq) {
                this.selectedFrequency = freq;
                this.updateButtonSelection('#frequencies', 'data-freq', freq.toString());
                document.getElementById('submitAnswer').disabled = false;
            }

            async submitAnswer() {
                await this.stopCurrentAudio();
                const question = this.questions[this.currentQuestion];
                const result = this.calculateScore(question);
                this.score += result.score;
                this.questionResults.push(result);
                this.setText('currentScore', this.score.toFixed(1));
                this.showFeedback(result.feedbackText, result.feedbackClass);
                this.hideQuestionControls();
                this.show('nextQuestion');
                document.getElementById('progressBar').style.width = `${((this.currentQuestion + 1) / this.NUM_QUESTIONS) * 100}%`;
            }

            calculateScore(question) {
                let questionScore = 0, feedbackClass = 'incorrect', feedbackText = 'Incorrect.';
                const submittedType = this.selectedFilterType, submittedFreq = this.selectedFrequency;

                if (this.settings.useFixedFilter) {
                    if (submittedFreq === question.frequency) {
                        questionScore = 1.0; feedbackClass = 'correct'; feedbackText = '✅ Correct frequency!';
                    } else {
                        feedbackClass = 'incorrect';
                        feedbackText = `❌ Incorrect frequency. The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                    }
                } else {
                    const correctType = submittedType === question.filterType;
                    if (question.filterType === 'Lowpass' || question.filterType === 'Highpass') {
                        if (correctType) {
                            questionScore = 1.0; feedbackClass = 'correct';
                            feedbackText = `✅ Correct! It was a ${question.filterType} filter.`;
                        } else { feedbackClass = 'incorrect'; feedbackText = '❌ Incorrect type.'; }
                    } else {
                        const correctFreq = submittedFreq === question.frequency;
                        if (correctType && correctFreq) {
                            questionScore = 1.0; feedbackClass = 'correct';
                            feedbackText = `✅ Perfect! It was a ${question.filterType} filter at ${question.frequency} Hz (${question.label}).`;
                        } else if (correctType && !correctFreq) {
                            questionScore = 0.5; feedbackClass = 'partial';
                            feedbackText = `⚠️ Partially Correct. You identified the type '${question.filterType}', but the frequency was incorrect.`;
                        } else { feedbackClass = 'incorrect'; feedbackText = '❌ Incorrect.'; }
                    }
                }

                let fullFeedbackText = feedbackText;
                if (!this.settings.useFixedFilter && this.settings.showTypeAnswers && feedbackClass === 'incorrect') {
                    fullFeedbackText += `<br>The correct filter type was: ${question.filterType}.`;
                }
                if ((question.filterType === 'Notch' || question.filterType === 'Bandpass') && submittedFreq !== question.frequency) {
                    if (this.settings.useFixedFilter || (submittedType === question.filterType) || (!this.settings.useFixedFilter && submittedType !== question.filterType)) {
                        fullFeedbackText += `<br>The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                    }
                }
                if (this.settings.showDetails) fullFeedbackText += `<br><br><strong>Filter Details:</strong> ${question.details}`;

                return { score: questionScore, feedbackClass, feedbackText: fullFeedbackText, question, submittedType, submittedFreq };
            }

            showFeedback(text, className) {
                const feedback = document.getElementById('feedback');
                feedback.innerHTML = text;
                feedback.className = `feedback ${className}`;
                this.show('feedback');
            }

            hideQuestionControls() {
                this.hide('playSection'); this.hide('guessSection'); this.hide('audioStatus');
            }

            async nextQuestion() {
                await this.stopCurrentAudio();
                this.currentQuestion++;
                if (this.currentQuestion < this.NUM_QUESTIONS) await this.loadQuestion();
                else this.endQuiz();
            }

            endQuiz() {
                this.stopCurrentAudio();
                this.hide('quiz');
                this.show('results');
                const percentage = (this.score / this.NUM_QUESTIONS) * 100;
                this.setHTML('finalScore', `<div class="score">${this.score.toFixed(1)}/${this.NUM_QUESTIONS}</div><div>${percentage.toFixed(1)}% Accuracy</div>`);
                this.showPerformanceAnalysis();
            }

            showPerformanceAnalysis() {
                const typeAccuracy = {}, freqAccuracy = {};
                this.FILTER_TYPES.forEach(type => typeAccuracy[type] = {correct: 0, total: 0});
                this.NOTCH_BAND_FREQ_LIST.forEach(freq => freqAccuracy[freq] = {correct: 0, total: 0});

                this.questionResults.forEach(result => {
                    const {question, submittedType, submittedFreq} = result;
                    typeAccuracy[question.filterType].total++;
                    if (submittedType === question.filterType) typeAccuracy[question.filterType].correct++;
                    if (question.filterType === 'Notch' || question.filterType === 'Bandpass') {
                        freqAccuracy[question.frequency].total++;
                        if (submittedFreq === question.frequency) freqAccuracy[question.frequency].correct++;
                    }
                });

                let analysis = '<div class="card"><h3>📊 Performance Analysis</h3>';
                analysis += '<h4>Filter Type Accuracy</h4><ul style="margin-left: 1.25rem;">';
                Object.entries(typeAccuracy).forEach(([type, data]) => {
                    if (data.total > 0) {
                        const percent = ((data.correct / data.total) * 100).toFixed(0);
                        analysis += `<li><strong>${type}:</strong> ${data.correct}/${data.total} (${percent}%)</li>`;
                    }
                });
                analysis += '</ul>';

                const freqData = Object.entries(freqAccuracy).filter(([_, data]) => data.total > 0);
                if (freqData.length > 0) {
                    analysis += '<h4>Frequency Accuracy</h4><ul style="margin-left: 1.25rem;">';
                    freqData.forEach(([freq, data]) => {
                        const percent = ((data.correct / data.total) * 100).toFixed(0);
                        const label = this.NOTCH_BAND_CHOICES[freq];
                        analysis += `<li><strong>${freq} Hz (${label}):</strong> ${data.correct}/${data.total} (${percent}%)</li>`;
                    });
                    analysis += '</ul>';
                }
                analysis += '</div>';
                this.setHTML('performanceAnalysis', analysis);
            }

            restartQuiz() {
                this.stopCurrentAudio();
                this.currentQuestion = 0; this.score = 0; this.questions = []; this.questionResults = [];
                this.selectedFilterType = null; this.selectedFrequency = null;
                this.exampleSelectedFilterType = null; this.exampleSelectedFrequency = null; this.exampleOriginalAudioData = null;
                this.hide('results'); this.hide('quiz'); this.show('setup');
                this.restoreSettings(); this.updateUI(); this.prepareExampleAudio(); this.updateExamplePlayButtonState();
                document.getElementById('progressBar').style.width = '0%';
                this.hide('audioStatus'); this.hide('exampleStatus');
                this.clearButtonSelections('#exampleFilterTypes'); this.clearButtonSelections('#exampleFrequencies');
                this.hide('exampleFrequencySection');

                if (this.settings.useCustomAudio) {
                    if (this.settings.useRandomSegments) document.getElementById('startButton').disabled = !this.customAudioBuffer;
                    else document.getElementById('startButton').disabled = !this.selectedAudioSegment;
                } else document.getElementById('startButton').disabled = false;
            }

            selectExampleFilterType(type) {
                this.exampleSelectedFilterType = type;
                this.exampleSelectedFrequency = null;
                this.exampleOriginalAudioData = null;
                this.updateButtonSelection('#exampleFilterTypes', 'data-type', type);
                this.clearButtonSelections('#exampleFrequencies');
                if (type === 'Notch' || type === 'Bandpass') {
                    this.show('exampleFrequencySection');
                    this.updateExamplePlayButtonState();
                } else {
                    this.hide('exampleFrequencySection');
                    this.prepareExampleAudio();
                    this.updateExamplePlayButtonState();
                }
                this.hide('exampleStatus');
            }

            selectExampleFrequency(freq) {
                this.exampleSelectedFrequency = freq;
                this.exampleOriginalAudioData = null;
                this.updateButtonSelection('#exampleFrequencies', 'data-freq', freq.toString());
                this.prepareExampleAudio();
                this.updateExamplePlayButtonState();
                this.hide('exampleStatus');
            }

            prepareExampleAudio() {
                const duration = this.settings.userDuration;
                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                let canGenerate = false;
                if (audioSourceValue === 'pink') canGenerate = true;
                else if (audioSourceValue === 'random' && this.customAudioBuffer) {
                    const requiredSamples = Math.floor(duration * 44100);
                    canGenerate = this.customAudioBuffer.length >= requiredSamples;
                } else if (audioSourceValue === 'file' && this.selectedAudioSegment && this.selectedAudioSegment.length > 0) canGenerate = true;

                if (canGenerate) this.exampleOriginalAudioData = this.getExampleOriginalAudioData(duration);
                else this.exampleOriginalAudioData = null;
            }

            getExampleOriginalAudioData(duration) {
                const numSamples = Math.floor(duration * 44100);
                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;

                if (audioSourceValue === 'file' && this.selectedAudioSegment) {
                    if (this.selectedAudioSegment.length >= numSamples) return this.selectedAudioSegment.slice(0, numSamples);
                    else {
                        const paddedData = new Float32Array(numSamples);
                        let sourceIndex = 0;
                        for (let i = 0; i < numSamples; i++) {
                            paddedData[i] = this.selectedAudioSegment[sourceIndex % this.selectedAudioSegment.length];
                            sourceIndex++;
                        }
                        return paddedData;
                    }
                } else if (audioSourceValue === 'random' && this.customAudioBuffer) {
                    if (this.customAudioBuffer.length < numSamples) {
                        this.showStatus('exampleStatus', `Uploaded file is too short for ${duration}s duration.`, 'error');
                        return null;
                    }
                    return this.getRandomSegment(duration);
                } else if (audioSourceValue === 'pink') return this.generatePinkNoise(duration);
                else {
                    if (audioSourceValue === 'file') this.showStatus('exampleStatus', 'Please upload and select an audio segment first.', 'error');
                    else if (audioSourceValue === 'random') this.showStatus('exampleStatus', 'Please upload an audio file first.', 'error');
                    return null;
                }
            }

            async playExampleOriginal() {
                if (!this.exampleOriginalAudioData) {
                    this.showStatus('exampleStatus', 'Audio source data not ready.', 'error');
                    return;
                }
                this.showStatus('exampleStatus', 'Playing original...', 'info');
                try {
                    await this.playAudioData(this.exampleOriginalAudioData);
                    this.showStatus('exampleStatus', 'Done.', 'success', 1000);
                } catch (e) {
                    console.error("Error playing example original:", e);
                    this.showStatus('exampleStatus', 'Error playing original audio.', 'error');
                }
            }

            async playExampleFiltered() {
                const type = this.exampleSelectedFilterType, freq = this.exampleSelectedFrequency, duration = this.settings.userDuration;
                if (!type) { this.showStatus('exampleStatus', 'Please select a filter type.', 'error'); return; }
                if ((type === 'Notch' || type === 'Bandpass') && freq === null) {
                    this.showStatus('exampleStatus', 'Please select a center frequency.', 'error'); return;
                }
                if (!this.exampleOriginalAudioData) { this.showStatus('exampleStatus', 'Audio source data not ready.', 'error'); return; }

                document.getElementById('playExampleFiltered').disabled = true;
                this.showStatus('exampleStatus', '<div class="loading-spinner"></div>Generating filtered audio...', 'info');

                try {
                    const filterFreq = freq || (type === 'Lowpass' ? 5000 : 150);
                    const filteredAudioBuffer = await this.applyFilter(this.exampleOriginalAudioData, type, filterFreq, duration);
                    this.showStatus('exampleStatus', 'Playing filtered...', 'info');
                    await this.playAudioBuffer(filteredAudioBuffer);
                    this.showStatus('exampleStatus', 'Done.', 'success', 1000);
                } catch (e) {
                    console.error("Error playing example filtered:", e);
                    this.showStatus('exampleStatus', 'Error playing filtered audio.', 'error');
                } finally {
                    document.getElementById('playExampleFiltered').disabled = false;
                }
            }

            updateExamplePlayButtonState() {
                const playFilteredButton = document.getElementById('playExampleFiltered');
                const playOriginalButton = document.getElementById('playExampleOriginal');
                let canPlayFiltered = false;
                if (this.exampleSelectedFilterType !== null) {
                    if (this.exampleSelectedFilterType === 'Notch' || this.exampleSelectedFilterType === 'Bandpass') {
                        if (this.exampleSelectedFrequency !== null && this.exampleOriginalAudioData !== null) canPlayFiltered = true;
                    } else {
                        if (this.exampleOriginalAudioData !== null) canPlayFiltered = true;
                    }
                }
                const canPlayOriginal = this.exampleOriginalAudioData !== null;
                playFilteredButton.disabled = !canPlayFiltered;
                playOriginalButton.disabled = !canPlayOriginal;

                const audioSourceValue = document.querySelector('input[name="audioSource"]:checked').value;
                if (audioSourceValue === 'file') {
                    if (this.selectedAudioSegment) {
                        this.setText('exampleAudioSource', 'Selected Segment');
                        this.setText('exampleSourceNote', 'Using your selected audio segment');
                    } else {
                        this.setText('exampleAudioSource', 'Uploaded File (No segment selected)');
                        this.setText('exampleSourceNote', 'Please select a segment first');
                    }
                } else if (audioSourceValue === 'random') {
                    if (this.customAudioBuffer) {
                        this.setText('exampleAudioSource', 'Random Segment');
                        this.setText('exampleSourceNote', 'Using random segments from uploaded file');
                    } else {
                        this.setText('exampleAudioSource', 'Random Segment (No file uploaded)');
                        this.setText('exampleSourceNote', 'Please upload a file first');
                    }
                } else {
                    this.setText('exampleAudioSource', 'Pink Noise');
                    this.setText('exampleSourceNote', 'Using the audio sample duration setting');
                }
                this.setText('exampleDuration', this.settings.userDuration);
            }

            updateUI() {
                this.setText('exampleDuration', this.settings.userDuration);
                this.onAudioSourceChange(); this.onFilterModeChange();
                this.setText('filterTypeDisplay', document.getElementById('fixedFilterType').value);
                this.selectExampleFilterType(null); this.prepareExampleAudio(); this.updateExamplePlayButtonState();
            }
        }

        document.addEventListener('DOMContentLoaded', () => { new HearingTestQuiz(); });
    </script>
</body>
</html>