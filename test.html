<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hearing Test Quiz</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .setup-section, .question-section, .results-section {
            margin: 20px 0;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            border-left: 5px solid #4CAF50;
        }
         .info-box h3 {
             margin-top: 0;
             color: #bcf5bc; /* Lighter green for contrast */
         }

         .info-box ul {
             margin-bottom: 0;
             padding-left: 20px;
         }
         .info-box li {
             margin-bottom: 5px;
         }

        .question-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(76, 175, 80, 0.3);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(76, 175, 80, 0.4);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .play-button {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            font-size: 18px;
            padding: 15px 30px;
            box-shadow: 0 4px 15px 0 rgba(33, 150, 243, 0.3);
        }

        .play-button:hover:not(:disabled) {
            box-shadow: 0 6px 20px 0 rgba(33, 150, 243, 0.4);
        }

        .filter-options button.selected,
        .freq-options button.selected {
             background: #45a049; /* Darker green when selected */
        }

        select, input[type="file"] {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            padding: 12px;
            border-radius: 10px;
            margin: 8px;
            font-size: 16px;
            box-sizing: border-box; /* Include padding in width */
        }

        input[type="file"] {
             width: calc(100% - 16px); /* Adjust for margin */
        }

        label {
            display: inline-block;
            margin-bottom: 5px;
            margin-right: 15px; /* Spacing between radio buttons */
        }

        label input[type="radio"],
        label input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }

        .filter-options, .freq-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Adjusted min width */
            gap: 10px;
            margin: 15px 0;
        }
         .freq-options {
             grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Wider min width for frequencies */
         }

        .score-display {
            font-size: 1.5em;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .feedback {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .correct { border-left: 5px solid #4CAF50; }
        .incorrect { border-left: 5px solid #f44336; }
        .partial { border-left: 5px solid #FF9800; }

        .hidden { display: none; }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
        }

        .volume-warning {
            background: #ff9800;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
        }

        #playSection, #guessSection {
            margin-top: 30px;
        }
        #guessSection h4 {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéß Hearing Test Quiz</h1>

        <div class="volume-warning">
            ‚ö†Ô∏è Please set your volume to a comfortable level before starting! Use headphones for best results.
        </div>

        <div id="setup" class="setup-section">
            <div class="info-box">
                <h3>How it works:</h3>
                <p>You'll hear original audio, then filtered audio. Your task:</p>
                <ol>
                    <li>Identify the filter type: Lowpass, Highpass, Notch, or Bandpass</li>
                    <li>If it's Notch or Bandpass, also guess the center frequency from the options</li>
                </ol>
            </div>

            <div class="info-box">
                 <h3>Audio Sample Duration:</h3>
                 <div style="margin: 15px 0;">
                     <label for="sampleDuration">Choose Duration:</label>
                     <select id="sampleDuration">
                         <option value="1.0">1 second</option>
                         <option value="2.0">2 seconds</option>
                         <option value="3.0" selected>3 seconds (Default)</option>
                         <option value="5.0">5 seconds</option>
                     </select>
                 </div>
            </div>


            <div class="info-box">
                <h3>Audio Source:</h3>
                <div style="margin: 15px 0;">
                    <label>
                        <input type="radio" name="audioSource" value="pink" checked onchange="toggleAudioSource()">
                        Use Pink Noise (Default)
                    </label>
                    <label>
                        <input type="radio" name="audioSource" value="file" onchange="toggleAudioSource()">
                        Upload Audio File
                    </label>
                </div>

                <div id="fileSection" class="hidden" style="margin: 15px 0;">
                    <input type="file" id="audioFile" accept="audio/*" onchange="handleAudioFile()">
                    <div id="fileInfo" class="hidden" style="background: rgba(0,255,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        File loaded successfully! Duration: <span id="fileDuration"></span>s
                    </div>
                    <div id="fileError" class="hidden" style="background: rgba(255,0,0,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        Error loading file. Please try another.
                    </div>
                    <div id="fileRequirement" style="font-size: 0.9em; color: #ddd; margin: 5px 0;">
                        Supported: MP3, WAV, OGG, M4A. A random <span id="requiredDuration">3</span>-second segment will be used for each question.
                    </div>
                </div>
            </div>

            <div class="info-box">
                <h3>Filter Mode:</h3>
                <div style="margin: 15px 0;">
                    <label>
                        <input type="radio" name="filterMode" value="random" checked onchange="toggleFilterMode()">
                        Random Filter Types (All Types)
                    </label>
                    <label>
                        <input type="radio" name="filterMode" value="fixed" onchange="toggleFilterMode()">
                        Focus Mode (Notch/Bandpass Only)
                    </label>
                </div>

                <div id="fixedFilterSection" class="hidden" style="margin: 15px 0;">
                    <select id="fixedFilterType" onchange="toggleFixedFrequency()">
                        <option value="Notch">Notch Filter</option>
                        <option value="Bandpass">Bandpass Filter</option>
                    </select>

                    <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; margin: 10px 0;">
                        <strong>Focus Mode:</strong> The filter type is fixed to <strong><span id="filterTypeDisplay"></span></strong>.
                        You'll only need to identify the center frequency.
                    </div>
                </div>
            </div>

            <div class="info-box">
                <h3>Scoring:</h3>
                <ul>
                    <li><strong>Random Mode - Lowpass/Highpass:</strong> 1 point for correct type</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 1 point for correct type AND correct frequency</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 0.5 points for correct type but wrong frequency</li>
                    <li><strong>Focus Mode:</strong> 1 point for correct frequency (filter type is given)</li>
                </ul>
            </div>

            <div class="info-box">
                <h3>Options:</h3>
                <label>
                    <input type="checkbox" id="showTypeAnswers"> Show correct filter type if your guess is wrong (in Random mode)
                </label><br>
                <label>
                    <input type="checkbox" id="showDetails"> Show filter details (parameters) after each guess
                </label>
            </div>

            <div style="text-align: center; margin: 30px 0;">
                <button onclick="startQuiz()" class="play-button" id="startButton">Start Quiz (10 Questions)</button>
            </div>
        </div>

        <div id="quiz" class="question-section hidden">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>

            <div class="score-display">
                Question <span id="questionNum">1</span>/10 | Score: <span id="currentScore">0</span>/10
            </div>

            <div class="question-box">
                <h3 id="questionTitle">Question 1</h3>

                <div id="playSection">
                    <button onclick="playOriginal()" class="play-button">‚ñ∂Ô∏è Play Original</button>
                    <button onclick="playFiltered()" class="play-button">‚ñ∂Ô∏è Play Filtered</button>
                </div>
                 <div id="audioLoading" style="text-align:center; margin-top:10px; color: #ddd;"></div>


                <div id="guessSection" style="margin-top: 30px;">
                    <div id="filterTypeSection">
                        <h4>What type of filter was applied?</h4>
                        <div class="filter-options">
                            <button data-type="Lowpass" onclick="selectFilterType('Lowpass')">Lowpass</button>
                            <button data-type="Highpass" onclick="selectFilterType('Highpass')">Highpass</button>
                            <button data-type="Notch" onclick="selectFilterType('Notch')">Notch</button>
                            <button data-type="Bandpass" onclick="selectFilterType('Bandpass')">Bandpass</button>
                        </div>
                    </div>

                    <div id="frequencySection" class="hidden">
                        <h4>What's the center frequency?</h4>
                        <div class="freq-options">
                            <!-- Updated Frequency Buttons -->
                            <button data-freq="100" onclick="selectFrequency(100)">100 Hz (Low)</button>
                            <button data-freq="600" onclick="selectFrequency(600)">600 Hz (MidLow)</button>
                            <button data-freq="1500" onclick="selectFrequency(1500)">1500 Hz (Mid)</button>
                            <button data-freq="5000" onclick="selectFrequency(5000)">5000 Hz (Mid High)</button>
                            <button data-freq="8000" onclick="selectFrequency(8000)">8000 Hz (High)</button>
                            <button data-freq="10000" onclick="selectFrequency(10000)">10000 Hz (Very High)</button>
                        </div>
                    </div>

                    <div id="focusModeInfo" class="hidden" style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; margin: 20px 0;">
                        Filter type: <strong><span id="givenFilterType"></span></strong> - Just identify the frequency!
                    </div>

                    <button id="submitAnswer" onclick="submitAnswer()" disabled>Submit Answer</button>
                </div>

                <div id="feedback" class="feedback hidden"></div>
                <button id="nextQuestion" onclick="nextQuestion()" class="hidden">Next Question</button>
            </div>
        </div>

        <div id="results" class="results-section hidden">
            <div class="score-display">
                <h2>Quiz Complete!</h2>
                <div id="finalScore"></div>
            </div>
            <button onclick="restartQuiz()">Take Quiz Again</button>
        </div>
    </div>

    <script>
        // Audio context and configuration
        let audioContext = null; // Initialize lazily
        let currentQuestion = 0;
        let score = 0;
        let questions = [];
        let selectedFilterType = null;
        let selectedFrequency = null;
        let showTypeAnswers = false;
        let showDetails = false;
        let customAudioBuffer = null;
        let useCustomAudio = false;
        let useFixedFilter = false;
        let fixedFilterType = 'Notch'; // Default fixed type

        // --- New Variables ---
        let userDuration = 3.0; // User selected duration, default to 3.0
        let currentSourceNode = null; // To keep track of the currently playing audio node


        // Constants matching the Python version
        const FS = 44100;
        // const DURATION = 3.0; // This will now be determined by userDuration
        const NOISE_AMPLITUDE = 0.4;
        const NUM_QUESTIONS = 10;

        const FILTER_TYPES = ["Lowpass", "Highpass", "Notch", "Bandpass"];
        // Filter parameters (simplified Biquad equivalents)
        const LOWPASS_FREQ = 5000; // Cutoff for Lowpass (Can adjust if needed, but keeping based on image range)
        const HIGHPASS_FREQ = 150; // Cutoff for Highpass (Can adjust if needed, but keeping based on image range)
        const PEAK_EQ_GAIN_DB = 9.0; // Gain for Bandpass, -Gain for Notch
        const PEAK_EQ_BW_OCT = 1.6; // Bandwidth in octaves for Peaking (Notch/Bandpass)

        // --- Updated Frequency Ranges ---
        const NOTCH_BAND_CHOICES = {
            100: "Low",
            600: "MidLow",
            1500: "Mid",
            5000: "Mid High",
            8000: "High",
            10000: "Very High"
        };

        const NOTCH_BAND_FREQ_LIST = [100, 600, 1500, 5000, 8000, 10000]; // Added 100 Hz


        // --- Utility Functions ---

        // Generate pink noise using Voss-McCartney algorithm
        // Now accepts duration parameter
        function generatePinkNoise(duration, sampleRate) {
            const samples = Math.floor(duration * sampleRate);
            const nSources = 16; // Number of random sources
            const maxVal = 1.0 / nSources;
            const sources = new Array(nSources).fill(0);
            const pink = new Float32Array(samples);
            let acc = 0.0;

            for (let i = 0; i < samples; i++) {
                let changed = (i + 1) & -(i + 1);
                 let k = 0;
                 if (changed !== 0) {
                      // This calculates the index based on the lowest set bit (power of 2)
                      let temp = changed;
                      while (temp > 1) {
                          temp >>= 1;
                          k++;
                      }
                 } else { // i=0, changed=0
                     // For i=0, changed is 1. This block is technically not reached for i>=0.
                     // Keeping for robustness but the logic for k is usually sufficient.
                 }


                 const idxToChange = k % nSources; // Use modulo in case k > nSources (unlikely with 16)

                 // Only update source if changed indicates this index
                 // (1 << k) is equivalent to the calculated 'changed' value for i+1
                 if (changed === (1 << k)) {
                      acc -= sources[idxToChange];
                      const newVal = (Math.random() - 0.5) * 2 * maxVal; // Random value [-maxVal, maxVal]
                      sources[idxToChange] = newVal;
                      acc += newVal;
                 }


                pink[i] = acc;
            }

            // Simple DC offset removal and normalization
            const mean = pink.reduce((sum, val) => sum + val, 0) / pink.length;
            let maxAbs = 0;
            for (let i = 0; i < samples; i++) {
                pink[i] = pink[i] - mean; // Remove DC
                maxAbs = Math.max(maxAbs, Math.abs(pink[i]));
            }

            // Normalize to NOISE_AMPLITUDE
             if (maxAbs > 1e-6) { // Avoid division by zero/near-zero
                 const gain = NOISE_AMPLITUDE / maxAbs;
                 for (let i = 0; i < samples; i++) {
                     pink[i] *= gain;
                 }
             }


            return pink;
        }

        // Apply filter using OfflineAudioContext
        async function applyFilter(audioData, filterType, frequency, duration) { // Added duration
            if (!audioContext) {
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
             }

            // Create an offline context
            const numberOfChannels = 1; // Assuming mono for simplicity
            const bufferLength = Math.floor(duration * FS); // Use duration for length
             // Ensure the audioData is at least bufferLength long before slicing
             const dataToUse = audioData.length >= bufferLength ? audioData.slice(0, bufferLength) : audioData;


            const offlineContext = new OfflineAudioContext(numberOfChannels, bufferLength, FS);

            // Create source from audio data
            const source = offlineContext.createBufferSource();
            const audioBuffer = offlineContext.createBuffer(numberOfChannels, bufferLength, FS);
            // Set channel data, slice to duration if data was longer, or pad if shorter
            audioBuffer.getChannelData(0).set(new Float32Array(dataToUse)); // Use dataToUse

            source.buffer = audioBuffer;

            // Create the filter node
            const filter = offlineContext.createBiquadFilter();

            switch (filterType) {
                case 'Lowpass':
                    filter.type = 'lowpass';
                    filter.frequency.value = frequency; // Use LOWPASS_FREQ
                    filter.Q.value = Math.SQRT1_2; // Butterworth Q (~0.707)
                    break;
                case 'Highpass':
                    filter.type = 'highpass';
                    filter.frequency.value = frequency; // Use HIGHPASS_FREQ
                    filter.Q.value = Math.SQRT1_2; // Butterworth Q
                    break;
                case 'Notch':
                    filter.type = 'peaking'; // Use peaking filter for notch
                    filter.frequency.value = frequency; // Use center frequency
                    filter.gain.value = -PEAK_EQ_GAIN_DB; // Apply negative gain
                    // Calculate Q from bandwidth in octaves
                    filter.Q.value = frequency / (frequency * (Math.pow(2, PEAK_EQ_BW_OCT / 2) - Math.pow(2, -PEAK_EQ_BW_OCT / 2)));
                    break;
                case 'Bandpass':
                    filter.type = 'peaking'; // Use peaking filter for bandpass
                    filter.frequency.value = frequency; // Use center frequency
                    filter.gain.value = PEAK_EQ_GAIN_DB; // Apply positive gain
                    // Calculate Q from bandwidth in octaves
                    filter.Q.value = frequency / (frequency * (Math.pow(2, PEAK_EQ_BW_OCT / 2) - Math.pow(2, -PEAK_EQ_BW_OCT / 2)));
                    break;
                 default:
                    console.error("Unknown filter type:", filterType);
                    return audioBuffer; // Return original if filter type is unknown
            }

            // Connect nodes and start rendering
            source.connect(filter);
            filter.connect(offlineContext.destination);
            source.start();

            // Render the audio
            try {
                 const renderedBuffer = await offlineContext.startRendering();
                 return renderedBuffer; // This is an AudioBuffer object
             } catch (e) {
                 console.error("Rendering failed:", e);
                 return audioBuffer; // Return original on error
             }
        }

         // Play an AudioBuffer object - Modified to handle stopping previous audio
         async function playAudioBuffer(audioBuffer) {
             if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Ensure context is running, needed for some browsers resume policy
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            // --- Stop previous audio ---
            if (currentSourceNode && currentSourceNode.context.state === 'running') {
                try {
                    currentSourceNode.stop();
                    console.log("Stopped previous audio source."); // Debugging
                } catch (e) {
                    // This might throw if the node already finished or was stopped by other means
                    console.warn("Error trying to stop previous audio source:", e);
                }
            }
             // Do NOT immediately set currentSourceNode = null here.
             // The onended handler will clear it when the *new* source finishes.
             // If a new source starts before the old one's onended, the old one's
             // onended handler will correctly see that it's not the currentSourceNode
             // and won't nullify the new one.


            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            // Set the new source as the current one
            currentSourceNode = source;

            source.start();

            return new Promise(resolve => {
                source.onended = () => {
                    source.disconnect(); // Clean up
                    // Clear the reference only if it's still the current node
                    if (currentSourceNode === source) {
                         currentSourceNode = null;
                    }
                    resolve();
                }
            });
        }


        // --- Quiz Logic ---

        function generateQuestion() {
            let filterType, frequency, label, details;

            // Determine filter type
            if (useFixedFilter) {
                filterType = fixedFilterType;
                // Always vary frequency for notch/bandpass in fixed mode
                frequency = NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * NOTCH_BAND_FREQ_LIST.length)];
                label = NOTCH_BAND_CHOICES[frequency];
            } else {
                filterType = FILTER_TYPES[Math.floor(Math.random() * FILTER_TYPES.length)];
            }

            // Set frequency and details based on filter type
            switch (filterType) {
                case 'Lowpass':
                    frequency = LOWPASS_FREQ;
                    label = 'Lowpass'; // Simplified label
                    details = `Lowpass Filter (Cutoff: ${LOWPASS_FREQ} Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                    break;
                case 'Highpass':
                    frequency = HIGHPASS_FREQ;
                    label = 'Highpass'; // Simplified label
                    details = `Highpass Filter (Cutoff: ${HIGHPASS_FREQ} Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                    break;
                case 'Notch':
                case 'Bandpass':
                    if (!useFixedFilter) {
                         // If not fixed mode, frequency is chosen randomly here
                        frequency = NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * NOTCH_BAND_FREQ_LIST.length)];
                        label = NOTCH_BAND_CHOICES[frequency];
                    } else {
                        // If fixed mode, frequency was already picked above
                        label = NOTCH_BAND_CHOICES[frequency]; // Ensure label matches the picked freq
                    }
                    const gain = filterType === 'Notch' ? -PEAK_EQ_GAIN_DB : PEAK_EQ_GAIN_DB;
                    const calculatedQ = frequency / (frequency * (Math.pow(2, PEAK_EQ_BW_OCT / 2) - Math.pow(2, -PEAK_EQ_BW_OCT / 2)));
                    details = `${filterType} Filter (Center: ${frequency} Hz (${label}), BW: ${PEAK_EQ_BW_OCT} Oct, Gain: ${gain > 0 ? '+' : ''}${gain} dB, Q: ${calculatedQ.toFixed(2)})`;
                    break;
                 default: // Should not happen
                    frequency = 0; label = 'Unknown'; details = 'Unknown filter';
                    break;
            }

            // Generate or use custom audio
            let originalAudioData; // This will be a Float32Array
            const numSamples = Math.floor(userDuration * FS); // Use userDuration

            if (useCustomAudio && customAudioBuffer) {
                // Extract a random segment from the custom audio buffer
                const maxStartSample = Math.max(0, customAudioBuffer.length - numSamples);
                const startSample = Math.floor(Math.random() * (maxStartSample + 1));
                // Ensure we don't try to slice past the end of the buffer
                const endSample = Math.min(startSample + numSamples, customAudioBuffer.length);

                originalAudioData = customAudioBuffer.getChannelData(0).slice(startSample, endSample);

                // If the slice is shorter than userDuration (e.g., end of file), pad with silence
                 if (originalAudioData.length < numSamples) {
                     const paddedData = new Float32Array(numSamples);
                     paddedData.set(originalAudioData);
                     // The rest is silence (already initialized to 0)
                     originalAudioData = paddedData;
                 }


            } else {
                // Generate pink noise for userDuration
                originalAudioData = generatePinkNoise(userDuration, FS);
            }

            return {
                filterType, // The actual filter type applied
                frequency, // The actual characteristic frequency
                label, // The friendly label for the frequency (e.g., "Mid")
                details, // Full filter details string
                originalAudio: originalAudioData, // Float32Array data
                filteredAudio: null // AudioBuffer object, generated asynchronously in loadQuestion
            };
        }

        async function startQuiz() {
            // Initialize AudioContext if it hasn't been
             if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
             // Resume context if suspended (common browser policy)
             if (audioContext.state === 'suspended') {
                 await audioContext.resume();
             }

            // --- Read user selection for duration ---
             userDuration = parseFloat(document.getElementById('sampleDuration').value);
             const requiredSamples = Math.floor(userDuration * FS);


            showTypeAnswers = document.getElementById('showTypeAnswers').checked;
            showDetails = document.getElementById('showDetails').checked;

            // Get audio source preference
            useCustomAudio = document.querySelector('input[name="audioSource"]:checked').value === 'file';

            // Get filter mode preference
            useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';
            if (useFixedFilter) {
                fixedFilterType = document.getElementById('fixedFilterType').value;
            }

            // Validate custom audio if selected
            if (useCustomAudio && (!customAudioBuffer || customAudioBuffer.length < requiredSamples)) {
                alert(`Please upload an audio file that is at least ${userDuration} seconds long.`);
                return;
            }

            // Generate all questions
            questions = [];
            for (let i = 0; i < NUM_QUESTIONS; i++) {
                questions.push(generateQuestion());
            }

            currentQuestion = 0;
            score = 0;

            document.getElementById('setup').classList.add('hidden');
            document.getElementById('quiz').classList.remove('hidden');

            loadQuestion();
        }

        async function loadQuestion() {
            const question = questions[currentQuestion];

            // Reset UI elements
            document.getElementById('feedback').classList.add('hidden');
            document.getElementById('nextQuestion').classList.add('hidden');
            document.getElementById('submitAnswer').disabled = true; // Disabled until selection is made

            // Re-enable play and guess sections (visibility)
            document.getElementById('playSection').classList.remove('hidden');
            document.getElementById('guessSection').classList.remove('hidden');

             // Clear previous selections
             selectedFilterType = null;
             selectedFrequency = null;
             document.querySelectorAll('.filter-options button, .freq-options button').forEach(btn => {
                 btn.classList.remove('selected');
             });


            // Update UI
            document.getElementById('questionNum').textContent = currentQuestion + 1;
            document.getElementById('questionTitle').textContent = `Question ${currentQuestion + 1}`;
            document.getElementById('currentScore').textContent = score.toFixed(1);
            // Progress *before* current question starts loading
            document.getElementById('progressFill').style.width = `${((currentQuestion) / NUM_QUESTIONS) * 100}%`;
             document.getElementById('audioLoading').textContent = ''; // Clear previous loading text

            // Configure UI based on mode
            if (useFixedFilter) {
                // Hide filter type selection, show only frequency
                document.getElementById('filterTypeSection').classList.add('hidden');
                document.getElementById('frequencySection').classList.remove('hidden');
                document.getElementById('focusModeInfo').classList.remove('hidden');
                document.getElementById('givenFilterType').textContent = question.filterType;
                selectedFilterType = question.filterType; // Auto-select the known type
                 // Submit button remains disabled until frequency is selected
            } else {
                // Show filter type selection, hide frequency initially
                document.getElementById('filterTypeSection').classList.remove('hidden');
                document.getElementById('frequencySection').classList.add('hidden');
                document.getElementById('focusModeInfo').classList.add('hidden');
                selectedFilterType = null; // Ensure no type is pre-selected
                 // Submit button remains disabled until type is selected
            }

            // --- Audio Generation ---

            // Disable play buttons *before* starting audio rendering
            document.querySelectorAll('#playSection button').forEach(btn => btn.disabled = true);
             // Show loading indicator
             document.getElementById('audioLoading').textContent = 'Loading audio...';


            try {
                // Generate filtered audio asynchronously
                // Pass userDuration to applyFilter
                question.filteredAudio = await applyFilter(question.originalAudio, question.filterType, question.frequency, userDuration);

                // Audio is ready, *re-enable* play buttons
                document.querySelectorAll('#playSection button').forEach(btn => btn.disabled = false);
                 // Remove loading indicator
                 document.getElementById('audioLoading').textContent = '';


            } catch (e) {
                console.error("Failed to render filtered audio:", e);
                // Handle error - maybe skip question or show error message
                document.getElementById('feedback').textContent = "Error generating audio for this question. Skipping.";
                document.getElementById('feedback').className = 'feedback incorrect'; // Use incorrect style for error
                document.getElementById('feedback').classList.remove('hidden');
                document.getElementById('nextQuestion').classList.remove('hidden'); // Allow skipping
                // Play buttons remain disabled due to the error

                document.getElementById('guessSection').classList.add('hidden'); // Hide guess section
                 // Update loading indicator to error message
                 document.getElementById('audioLoading').textContent = "Audio failed to load.";
                 document.getElementById('audioLoading').style.color = '#f44336'; // Red color for error


                return; // Stop loading this question normally
            }

            // --- Post-Audio-Generation Setup ---
            // The submit button is enabled by selectFilterType/selectFrequency calls after the user makes a selection.
            // No need to enable it here.

        }

        async function playOriginal() {
            const question = questions[currentQuestion];
            // playAudioBuffer expects an AudioBuffer, originalAudio is Float32Array
            // Need to create a temporary AudioBuffer of the correct duration
            if (!audioContext) {
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
             }
             const numSamples = Math.floor(userDuration * FS);
            const tempBuffer = audioContext.createBuffer(1, numSamples, FS);
            // Copy only the required number of samples
            tempBuffer.getChannelData(0).set(question.originalAudio.slice(0, numSamples));
            await playAudioBuffer(tempBuffer);
        }

        async function playFiltered() {
            const question = questions[currentQuestion];
            // filteredAudio is already an AudioBuffer from applyFilter
            if (question.filteredAudio) {
                 await playAudioBuffer(question.filteredAudio);
            } else {
                console.warn("Filtered audio not yet loaded.");
            }
        }

        function selectFilterType(type) {
            selectedFilterType = type;

            // Update button styles
            document.querySelectorAll('.filter-options button').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.getAttribute('data-type') === type) {
                    btn.classList.add('selected');
                }
            });

            // Show frequency selection for Notch/Bandpass, hide for others
            if (type === 'Notch' || type === 'Bandpass') {
                document.getElementById('frequencySection').classList.remove('hidden');
                 // Clear frequency selection state and button styles
                 selectedFrequency = null;
                 document.querySelectorAll('.freq-options button').forEach(btn => btn.classList.remove('selected'));
                document.getElementById('submitAnswer').disabled = true; // Require frequency selection
            } else { // Lowpass or Highpass
                document.getElementById('frequencySection').classList.add('hidden');
                selectedFrequency = null; // Clear any previous frequency selection
                 document.querySelectorAll('.freq-options button').forEach(btn => btn.classList.remove('selected')); // Clear freq button styles
                document.getElementById('submitAnswer').disabled = false; // Only type is needed
            }
        }

        function selectFrequency(freq) {
            selectedFrequency = freq;

            // Update button styles
            document.querySelectorAll('.freq-options button').forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.getAttribute('data-freq')) === freq) {
                    btn.classList.add('selected');
                }
            });

            document.getElementById('submitAnswer').disabled = false; // Frequency is selected
        }

        function submitAnswer() {
             // Stop any currently playing audio before showing feedback
             if (currentSourceNode && currentSourceNode.context.state === 'running') {
                 try {
                    currentSourceNode.stop();
                 } catch (e) {
                     console.warn("Error stopping audio on submit:", e);
                 }
                  currentSourceNode = null; // Clear the reference after stopping
             }

            const question = questions[currentQuestion];
            let questionScore = 0;
            let feedbackClass = 'incorrect';
            let feedbackText = 'Incorrect.';

            const submittedType = selectedFilterType;
            const submittedFreq = selectedFrequency;

            // Scoring Logic
            if (useFixedFilter) {
                // In fixed mode, filter type is given, only score on frequency
                if (submittedFreq === question.frequency) {
                    questionScore = 1.0;
                    feedbackClass = 'correct';
                    feedbackText = 'Correct frequency!';
                } else {
                    feedbackClass = 'incorrect';
                    feedbackText = `Incorrect frequency. The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                }
            } else {
                // Random mode - score based on type and frequency
                const correctType = submittedType === question.filterType;

                if (question.filterType === 'Lowpass' || question.filterType === 'Highpass') {
                    // For LP/HP, only type matters
                    if (correctType) {
                        questionScore = 1.0;
                        feedbackClass = 'correct';
                        feedbackText = 'Correct! It was a ' + question.filterType + ' filter.';
                    } else {
                         feedbackClass = 'incorrect';
                         feedbackText = `Incorrect type.`;
                    }
                } else { // Notch or Bandpass
                    // For Notch/BP, both type and frequency matter
                    const correctFreq = submittedFreq === question.frequency;

                    if (correctType && correctFreq) {
                        questionScore = 1.0;
                        feedbackClass = 'correct';
                        feedbackText = `Correct! It was a ${question.filterType} filter at ${question.frequency} Hz (${question.label}).`;
                    } else if (correctType && !correctFreq) {
                        questionScore = 0.5;
                        feedbackClass = 'partial';
                        feedbackText = `Partially Correct. You identified the type '${question.filterType}', but the frequency was incorrect.`;
                    } else { // Wrong type
                        feedbackClass = 'incorrect';
                        feedbackText = `Incorrect.`;
                    }
                }
            }

            score += questionScore;

            // Update score display immediately
            document.getElementById('currentScore').textContent = score.toFixed(1);

            // Build feedback message
            let fullFeedbackText = feedbackText;

            if (!useFixedFilter && showTypeAnswers && feedbackClass === 'incorrect') {
                 // Only show correct type in random mode if the guess was wrong
                 fullFeedbackText += `<br>The correct filter type was: ${question.filterType}.`;
            }

            // Add correct frequency info if the frequency guess was wrong AND the filter was Notch/Bandpass
             if ((question.filterType === 'Notch' || question.filterType === 'Bandpass') && submittedFreq !== question.frequency) {
                 // Check if we should show the correct frequency. This happens if:
                 // 1. It's fixed mode (type is given, only frequency matters)
                 // 2. It's random mode, the type guess was correct (partial score), and the frequency was wrong
                 // 3. It's random mode, the type guess was wrong, but the actual filter *was* Notch/Bandpass (show the freq info as context)
                 if (useFixedFilter || (submittedType === question.filterType) || (!useFixedFilter && submittedType !== question.filterType)) {
                       fullFeedbackText += `<br>The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                 }
             }


            if (showDetails) {
                fullFeedbackText += `<br><br>Filter Details: ${question.details}`;
            }

            // Display feedback
            document.getElementById('feedback').innerHTML = fullFeedbackText;
            document.getElementById('feedback').className = `feedback ${feedbackClass}`; // Apply feedback color class
            document.getElementById('feedback').classList.remove('hidden');


            // Hide play and guess sections
            document.getElementById('playSection').classList.add('hidden');
            document.getElementById('guessSection').classList.add('hidden');
            document.getElementById('audioLoading').textContent = ''; // Clear loading/error message


            // Show next question button
            document.getElementById('nextQuestion').classList.remove('hidden');

             // Update progress bar for the completed question
            document.getElementById('progressFill').style.width = `${((currentQuestion + 1) / NUM_QUESTIONS) * 100}%`;

        }

        function nextQuestion() {
             // Stop any currently playing audio when moving to the next question
             if (currentSourceNode && currentSourceNode.context.state === 'running') {
                 try {
                    currentSourceNode.stop();
                 } catch (e) {
                      console.warn("Error stopping audio on next question:", e);
                 }
                 currentSourceNode = null; // Clear the reference after stopping
             }

            currentQuestion++;

            if (currentQuestion < NUM_QUESTIONS) {
                loadQuestion(); // Load the next question
            } else {
                endQuiz(); // End the quiz
            }
        }

        function endQuiz() {
             // Stop any currently playing audio when ending the quiz
             if (currentSourceNode && currentSourceNode.context.state === 'running') {
                 try {
                    currentSourceNode.stop();
                 } catch (e) {
                     console.warn("Error stopping audio on quiz end:", e);
                 }
                 currentSourceNode = null; // Clear the reference after stopping
             }

            document.getElementById('quiz').classList.add('hidden');
            document.getElementById('results').classList.remove('hidden');
            document.getElementById('finalScore').textContent = `Your final score is: ${score.toFixed(1)}/${NUM_QUESTIONS}`;
        }

        function restartQuiz() {
            // Stop any currently playing audio before restarting
             if (currentSourceNode && currentSourceNode.context.state === 'running') {
                 try {
                    currentSourceNode.stop();
                 } catch (e) {
                      console.warn("Error stopping audio on restart:", e);
                 }
                 currentSourceNode = null; // Clear the reference after stopping
             }
            // Simple page reload to reset everything
            window.location.reload();
        }

        // --- Setup Options Handling ---

         // Update file requirement text when duration changes
         document.getElementById('sampleDuration').addEventListener('change', () => {
             const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
             document.getElementById('requiredDuration').textContent = selectedDuration;

             // Re-validate file length if custom audio is selected
              if (document.querySelector('input[name="audioSource"]:checked').value === 'file') {
                  const fileInput = document.getElementById('audioFile');
                  if (fileInput.files.length > 0) {
                      handleAudioFile(); // Re-run validation
                  } else {
                      // No file selected, just update button state based on duration
                       const requiredSamples = Math.floor(selectedDuration * FS);
                       document.getElementById('startButton').disabled = (!customAudioBuffer || customAudioBuffer.length < requiredSamples);
                  }
              } else {
                  // If not file mode, ensure button is enabled
                  document.getElementById('startButton').disabled = false;
              }
         });


        function toggleAudioSource() {
            const audioSource = document.querySelector('input[name="audioSource"]:checked').value;
            const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
            const requiredSamples = Math.floor(selectedDuration * FS);


            if (audioSource === 'file') {
                document.getElementById('fileSection').classList.remove('hidden');
                // Disable start button if file is not yet loaded/valid or too short
                document.getElementById('startButton').disabled = !customAudioBuffer || customAudioBuffer.length < requiredSamples;
            } else {
                document.getElementById('fileSection').classList.add('hidden');
                 document.getElementById('fileInfo').classList.add('hidden'); // Hide info/error if switching back
                 document.getElementById('fileError').classList.add('hidden');
                document.getElementById('startButton').disabled = false; // Enable for pink noise
            }
        }

        async function handleAudioFile() {
            const fileInput = document.getElementById('audioFile');
            const file = fileInput.files[0];
            const fileInfo = document.getElementById('fileInfo');
            const fileError = document.getElementById('fileError');
            const startButton = document.getElementById('startButton');

             // Get the currently selected duration
             const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
             const requiredSamples = Math.floor(selectedDuration * FS);

            fileInfo.classList.add('hidden');
            fileError.classList.add('hidden');
            customAudioBuffer = null; // Clear previous buffer
            startButton.disabled = true; // Disable while processing

            if (!file) {
                return; // No file selected, button remains disabled
            }

             // Ensure AudioContext is created for decoding
             if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
             }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // Decode audio data asynchronously
                    const audioBuffer = await audioContext.decodeAudioData(e.target.result);
                    customAudioBuffer = audioBuffer;

                    if (customAudioBuffer.length < requiredSamples) {
                         fileInfo.classList.add('hidden');
                         fileError.textContent = `File is shorter than ${selectedDuration} seconds (${customAudioBuffer.duration.toFixed(2)}s). Please select a longer file.`;
                         fileError.classList.remove('hidden');
                         startButton.disabled = true;
                         customAudioBuffer = null; // Invalidate buffer if too short
                    } else {
                         document.getElementById('fileDuration').textContent = audioBuffer.duration.toFixed(2);
                         fileInfo.classList.remove('hidden');
                         startButton.disabled = false; // Enable start button
                         fileError.classList.add('hidden'); // Hide any previous error
                    }


                } catch (error) {
                    console.error("Error decoding audio file:", error);
                    fileError.textContent = `Error decoding audio file: ${error.message}`;
                    fileError.classList.remove('hidden');
                    startButton.disabled = true; // Keep start button disabled
                }
            };
            reader.onerror = (e) => {
                console.error("Error reading audio file:", e);
                fileError.textContent = "Error reading audio file.";
                fileError.classList.remove('hidden');
                startButton.disabled = true; // Keep start button disabled
            };
            reader.readAsArrayBuffer(file);
        }

        function toggleFilterMode() {
            useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';
            if (useFixedFilter) {
                document.getElementById('fixedFilterSection').classList.remove('hidden');
                 // Set the initial fixed type display
                fixedFilterType = document.getElementById('fixedFilterType').value;
                document.getElementById('filterTypeDisplay').textContent = fixedFilterType;

            } else {
                document.getElementById('fixedFilterSection').classList.add('hidden');
                 fixedFilterType = null; // Clear fixed type if not in fixed mode
            }
        }

        function toggleFixedFrequency() {
            // Update the displayed fixed filter type when the select changes
            fixedFilterType = document.getElementById('fixedFilterType').value;
            document.getElementById('filterTypeDisplay').textContent = fixedFilterType;
        }

        // Initial setup state
        document.addEventListener('DOMContentLoaded', () => {
             // Update file requirement text on page load based on default duration
             document.getElementById('requiredDuration').textContent = parseFloat(document.getElementById('sampleDuration').value);

             toggleAudioSource(); // Initialize file section visibility and button state
             toggleFilterMode(); // Initialize fixed filter section visibility
             // Set initial fixed type text
             document.getElementById('filterTypeDisplay').textContent = document.getElementById('fixedFilterType').value;
        });


    </script>
</body>
</html>