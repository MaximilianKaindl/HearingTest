<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hearing Test Quiz</title>
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.18);
            --success-color: #4CAF50;
            --warning-color: #FF9800;
            --error-color: #f44336;
            --info-color: #2196F3;
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: var(--primary-gradient);
            color: white;
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid var(--glass-border);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #fff, #e3f2fd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .info-box, .question-box {
            background: rgba(255, 255, 255, 0.15);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            transition: var(--transition);
        }

        .info-box:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .info-box.success { border-left: 5px solid var(--success-color); }
        .info-box.info { border-left: 5px solid var(--info-color); }
        .info-box.warning { border-left: 5px solid var(--warning-color); }

        .info-box h3 {
            margin-top: 0;
            color: #bcf5bc;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .question-box {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
        }

        .btn {
            background: linear-gradient(45deg, var(--success-color), #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 8px;
            transition: var(--transition);
            box-shadow: 0 4px 15px 0 rgba(76, 175, 80, 0.3);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: var(--transition);
        }

        .btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--info-color), #1976D2);
            font-size: 18px;
            padding: 15px 30px;
            box-shadow: 0 4px 15px 0 rgba(33, 150, 243, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            box-shadow: 0 6px 20px 0 rgba(33, 150, 243, 0.4);
        }

        .btn.selected {
            background: #45a049;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }

        .grid {
            display: grid;
            gap: 10px;
            margin: 15px 0;
        }

        .grid-auto {
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .grid-freq {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .form-control {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            padding: 12px;
            border-radius: 10px;
            margin: 8px;
            font-size: 16px;
            width: 100%;
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.3);
        }

        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: var(--transition);
        }

        .radio-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: var(--transition);
        }

        .checkbox-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .progress-container {
            width: 100%;
            height: 25px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #45a049);
            transition: width 0.5s ease;
            border-radius: 15px;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .score-display {
            font-size: 1.5em;
            text-align: center;
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .feedback {
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
        }

        .feedback.correct {
            background: rgba(76, 175, 80, 0.2);
            border-left: 5px solid var(--success-color);
        }

        .feedback.incorrect {
            background: rgba(244, 67, 54, 0.2);
            border-left: 5px solid var(--error-color);
        }

        .feedback.partial {
            background: rgba(255, 152, 0, 0.2);
            border-left: 5px solid var(--warning-color);
        }

        .hidden { display: none; }

        .warning-box {
            background: var(--warning-color);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            transition: var(--transition);
        }

        .status-message.error {
            background: rgba(244, 67, 54, 0.2);
            color: #ffcdd2;
        }

        .status-message.success {
            background: rgba(76, 175, 80, 0.2);
            color: #c8e6c9;
        }

        .status-message.info {
            background: rgba(33, 150, 243, 0.2);
            color: #bbdefb;
        }

        .file-upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
        }

        .file-upload-area:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.05);
        }

        .file-upload-area.dragover {
            border-color: var(--info-color);
            background: rgba(33, 150, 243, 0.1);
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .grid-auto, .grid-freq {
                grid-template-columns: 1fr;
            }
            
            .radio-group {
                flex-direction: column;
            }
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéß Hearing Test Quiz</h1>

        <div class="warning-box">
            ‚ö†Ô∏è Please set your volume to a comfortable level before starting! Use headphones for best results.
        </div>

        <div id="setup" class="setup-section">
            <div class="info-box success">
                <h3>üéØ How it works:</h3>
                <p>You'll hear original audio, then filtered audio. Your task:</p>
                <ol>
                    <li>Identify the filter type: Lowpass, Highpass, Notch, or Bandpass</li>
                    <li>If it's Notch or Bandpass, also guess the center frequency from the options</li>
                </ol>
            </div>

            <div class="info-box info">
                <h3>‚è±Ô∏è Audio Sample Duration:</h3>
                <select id="sampleDuration" class="form-control">
                    <option value="1.0">1 second</option>
                    <option value="2.0">2 seconds</option>
                    <option value="3.0" selected>3 seconds (Default)</option>
                    <option value="5.0">5 seconds</option>
                </select>
            </div>

            <div class="info-box info">
                <h3>üéµ Audio Source:</h3>
                <div class="radio-group">
                    <label class="radio-item">
                        <input type="radio" name="audioSource" value="pink" checked>
                        <span>Use Pink Noise (Default)</span>
                    </label>
                    <label class="radio-item">
                        <input type="radio" name="audioSource" value="file">
                        <span>Upload Audio File</span>
                    </label>
                </div>

                <div id="fileSection" class="hidden">
                    <div class="file-upload-area" onclick="document.getElementById('audioFile').click()">
                        <input type="file" id="audioFile" accept="audio/*" class="hidden">
                        <div>üìÅ Click to select audio file or drag and drop</div>
                        <small>Supported: MP3, WAV, OGG, M4A</small>
                    </div>
                    <div id="fileStatus" class="status-message hidden"></div>
                    <div class="status-message info">
                        A random <span id="requiredDuration">3</span>-second segment (resampled to 44100 Hz) will be used for each question.
                    </div>
                </div>
            </div>

            <div class="info-box info">
                <h3>üéõÔ∏è Filter Mode:</h3>
                <div class="radio-group">
                    <label class="radio-item">
                        <input type="radio" name="filterMode" value="random" checked>
                        <span>Random Filter Types (All Types)</span>
                    </label>
                    <label class="radio-item">
                        <input type="radio" name="filterMode" value="fixed">
                        <span>Focus Mode (Notch/Bandpass Only)</span>
                    </label>
                </div>

                <div id="fixedFilterSection" class="hidden">
                    <select id="fixedFilterType" class="form-control">
                        <option value="Notch">Notch Filter</option>
                        <option value="Bandpass">Bandpass Filter</option>
                    </select>
                    <div class="info-box warning">
                        <strong>Focus Mode:</strong> The filter type is fixed to <strong><span id="filterTypeDisplay">Notch</span></strong>.
                        You'll only need to identify the center frequency.
                    </div>
                </div>
            </div>

            <div id="exampleSection" class="info-box info">
                <h3>üîä Hear Filter Examples:</h3>
                <p>Select a filter type and frequency to hear what the filtered audio sounds like.</p>

                <h4>Filter Type:</h4>
                <div class="grid grid-auto" id="exampleFilterTypes">
                    <button class="btn" data-type="Lowpass">Lowpass</button>
                    <button class="btn" data-type="Highpass">Highpass</button>
                    <button class="btn" data-type="Notch">Notch</button>
                    <button class="btn" data-type="Bandpass">Bandpass</button>
                </div>

                <div id="exampleFrequencySection" class="hidden">
                    <h4>Center Frequency:</h4>
                    <div class="grid grid-freq" id="exampleFrequencies">
                        <button class="btn" data-freq="100">100 Hz (Low)</button>
                        <button class="btn" data-freq="600">600 Hz (Mid-Low)</button>
                        <button class="btn" data-freq="1500">1500 Hz (Mid)</button>
                        <button class="btn" data-freq="5000">5000 Hz (Mid-High)</button>
                        <button class="btn" data-freq="8000">8000 Hz (High)</button>
                        <button class="btn" data-freq="10000">10000 Hz (Very High)</button>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <button id="playExampleOriginal" class="btn btn-primary" disabled>‚ñ∂Ô∏è Play Original</button>
                    <button id="playExampleFiltered" class="btn btn-primary" disabled>‚ñ∂Ô∏è Play Filtered</button>
                </div>
                <div id="exampleStatus" class="status-message hidden"></div>
                <div class="status-message info">
                    Audio source: <span id="exampleAudioSource">Pink Noise</span> | Duration: <span id="exampleDuration">3</span> seconds
                </div>
            </div>

            <div class="info-box success">
                <h3>üìä Scoring:</h3>
                <ul>
                    <li><strong>Random Mode - Lowpass/Highpass:</strong> 1 point for correct type</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 1 point for correct type AND correct frequency</li>
                    <li><strong>Random Mode - Notch/Bandpass:</strong> 0.5 points for correct type but wrong frequency</li>
                    <li><strong>Focus Mode:</strong> 1 point for correct frequency (filter type is given)</li>
                </ul>
            </div>

            <div class="info-box info">
                <h3>‚öôÔ∏è Options:</h3>
                <label class="checkbox-item">
                    <input type="checkbox" id="showTypeAnswers">
                    <span>Show correct filter type if your guess is wrong (in Random mode)</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" id="showDetails">
                    <span>Show filter details (parameters) after each guess</span>
                </label>
            </div>

            <div style="text-align: center; margin: 30px 0;">
                <button id="startButton" class="btn btn-primary">üöÄ Start Quiz (10 Questions)</button>
            </div>
        </div>

        <div id="quiz" class="question-section hidden">
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
                <div class="progress-text">
                    Question <span id="questionNum">1</span>/10
                </div>
            </div>

            <div class="score-display">
                Score: <span id="currentScore">0</span>/10
            </div>

            <div class="question-box">
                <h3 id="questionTitle">Question 1</h3>

                <div id="playSection">
                    <button id="playOriginal" class="btn btn-primary">‚ñ∂Ô∏è Play Original</button>
                    <button id="playFiltered" class="btn btn-primary">‚ñ∂Ô∏è Play Filtered</button>
                </div>
                <div id="audioStatus" class="status-message hidden"></div>

                <div id="guessSection">
                    <div id="filterTypeSection">
                        <h4>What type of filter was applied?</h4>
                        <div class="grid grid-auto" id="filterTypes">
                            <button class="btn" data-type="Lowpass">Lowpass</button>
                            <button class="btn" data-type="Highpass">Highpass</button>
                            <button class="btn" data-type="Notch">Notch</button>
                            <button class="btn" data-type="Bandpass">Bandpass</button>
                        </div>
                    </div>

                    <div id="frequencySection" class="hidden">
                        <h4>What's the center frequency?</h4>
                        <div class="grid grid-freq" id="frequencies">
                            <button class="btn" data-freq="100">100 Hz (Low)</button>
                            <button class="btn" data-freq="600">600 Hz (Mid-Low)</button>
                            <button class="btn" data-freq="1500">1500 Hz (Mid)</button>
                            <button class="btn" data-freq="5000">5000 Hz (Mid-High)</button>
                            <button class="btn" data-freq="8000">8000 Hz (High)</button>
                            <button class="btn" data-freq="10000">10000 Hz (Very High)</button>
                        </div>
                    </div>

                    <div id="focusModeInfo" class="hidden info-box warning">
                        Filter type: <strong><span id="givenFilterType"></span></strong> - Just identify the frequency!
                    </div>

                    <button id="submitAnswer" class="btn btn-primary" disabled>Submit Answer</button>
                </div>

                <div id="feedback" class="feedback hidden"></div>
                <button id="nextQuestion" class="btn btn-primary hidden">Next Question</button>
            </div>
        </div>

        <div id="results" class="results-section hidden">
            <div class="score-display">
                <h2>üéâ Quiz Complete!</h2>
                <div id="finalScore"></div>
                <div id="performanceAnalysis"></div>
            </div>
            <button id="restartButton" class="btn btn-primary">üîÑ Take Quiz Again</button>
        </div>
    </div>

    <script>
        class HearingTestQuiz {
            constructor() {
                this.audioContext = null;
                this.currentQuestion = 0;
                this.score = 0;
                this.questions = [];
                this.selectedFilterType = null;
                this.selectedFrequency = null;
                this.showTypeAnswers = false;
                this.showDetails = false;
                this.customAudioBuffer = null;
                this.useCustomAudio = false;
                this.useFixedFilter = false;
                this.fixedFilterType = 'Notch';
                this.userDuration = 3.0;
                this.currentSourceNode = null;
                this.exampleSelectedFilterType = null;
                this.exampleSelectedFrequency = null;
                this.exampleOriginalAudioData = null;
                this.questionResults = [];

                // Constants
                this.FS = 44100;
                this.NOISE_AMPLITUDE = 0.4;
                this.NUM_QUESTIONS = 10;
                this.FILTER_TYPES = ["Lowpass", "Highpass", "Notch", "Bandpass"];
                this.LOWPASS_FREQ = 5000;
                this.HIGHPASS_FREQ = 150;
                this.PEAK_EQ_GAIN_DB = 9.0;
                this.PEAK_EQ_BW_OCT = 1.6;
                this.NOTCH_BAND_CHOICES = {
                    100: "Low", 600: "Mid-Low", 1500: "Mid",
                    5000: "Mid-High", 8000: "High", 10000: "Very High"
                };
                this.NOTCH_BAND_FREQ_LIST = [100, 600, 1500, 5000, 8000, 10000];

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.updateUI();
                this.setupFileUpload();
            }

            setupEventListeners() {
                // Setup section
                document.getElementById('sampleDuration').addEventListener('change', () => this.onDurationChange());
                document.querySelectorAll('input[name="audioSource"]').forEach(input => {
                    input.addEventListener('change', () => this.onAudioSourceChange());
                });
                document.querySelectorAll('input[name="filterMode"]').forEach(input => {
                    input.addEventListener('change', () => this.onFilterModeChange());
                });
                document.getElementById('fixedFilterType').addEventListener('change', () => this.onFixedFilterTypeChange());
                document.getElementById('audioFile').addEventListener('change', () => this.handleAudioFile());
                document.getElementById('startButton').addEventListener('click', () => this.startQuiz());

                // Example section
                document.querySelectorAll('#exampleFilterTypes .btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectExampleFilterType(e.target.dataset.type));
                });
                document.querySelectorAll('#exampleFrequencies .btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectExampleFrequency(parseInt(e.target.dataset.freq)));
                });
                document.getElementById('playExampleOriginal').addEventListener('click', () => this.playExampleOriginal());
                document.getElementById('playExampleFiltered').addEventListener('click', () => this.playExampleFiltered());

                // Quiz section
                document.getElementById('playOriginal').addEventListener('click', () => this.playOriginal());
                document.getElementById('playFiltered').addEventListener('click', () => this.playFiltered());
                document.querySelectorAll('#filterTypes .btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectFilterType(e.target.dataset.type));
                });
                document.querySelectorAll('#frequencies .btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectFrequency(parseInt(e.target.dataset.freq)));
                });
                document.getElementById('submitAnswer').addEventListener('click', () => this.submitAnswer());
                document.getElementById('nextQuestion').addEventListener('click', () => this.nextQuestion());
                document.getElementById('restartButton').addEventListener('click', () => this.restartQuiz());
            }

            setupFileUpload() {
                const uploadArea = document.querySelector('.file-upload-area');
                
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'));
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'));
                });

                uploadArea.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        document.getElementById('audioFile').files = files;
                        this.handleAudioFile();
                    }
                });
            }

            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            showStatus(elementId, message, type = 'info', duration = 0) {
                const element = document.getElementById(elementId);
                element.className = `status-message ${type}`;
                element.innerHTML = message;
                element.classList.remove('hidden');
                
                if (duration > 0) {
                    setTimeout(() => element.classList.add('hidden'), duration);
                }
            }

            hideStatus(elementId) {
                document.getElementById(elementId).classList.add('hidden');
            }

            generatePinkNoise(duration, sampleRate) {
                const samples = Math.floor(duration * sampleRate);
                const nSources = 16;
                const maxVal = 1.0 / nSources;
                const sources = new Array(nSources).fill(0);
                const pink = new Float32Array(samples);
                let acc = 0.0;

                for (let i = 0; i < samples; i++) {
                    let changed = (i + 1) & -(i + 1);
                    let k = 0;
                    if (changed !== 0) {
                        let temp = changed;
                        while (temp > 1) {
                            temp >>= 1;
                            k++;
                        }
                    }
                    const idxToChange = k % nSources;

                    if (changed === (1 << k)) {
                        acc -= sources[idxToChange];
                        const newVal = (Math.random() - 0.5) * 2 * maxVal;
                        sources[idxToChange] = newVal;
                        acc += newVal;
                    }
                    pink[i] = acc;
                }

                // DC offset removal and normalization
                const mean = pink.reduce((sum, val) => sum + val, 0) / pink.length;
                let maxAbs = 0;
                for (let i = 0; i < samples; i++) {
                    pink[i] = pink[i] - mean;
                    maxAbs = Math.max(maxAbs, Math.abs(pink[i]));
                }

                if (maxAbs > 1e-6) {
                    const gain = this.NOISE_AMPLITUDE / maxAbs;
                    for (let i = 0; i < samples; i++) {
                        pink[i] *= gain;
                    }
                }

                return pink;
            }

            async applyFilter(audioData, filterType, frequency, duration) {
                await this.initAudioContext();

                const numberOfChannels = 1;
                const bufferLength = Math.floor(duration * this.FS);
                const dataToUse = new Float32Array(bufferLength);
                dataToUse.set(audioData.slice(0, bufferLength));

                const offlineContext = new OfflineAudioContext(numberOfChannels, bufferLength, this.FS);
                const source = offlineContext.createBufferSource();
                const audioBuffer = offlineContext.createBuffer(numberOfChannels, bufferLength, this.FS);
                audioBuffer.getChannelData(0).set(dataToUse);
                source.buffer = audioBuffer;

                const filter = offlineContext.createBiquadFilter();
                this.configureFilter(filter, filterType, frequency);

                source.connect(filter);
                filter.connect(offlineContext.destination);
                source.start();

                try {
                    return await offlineContext.startRendering();
                } catch (e) {
                    console.error("Filter rendering failed:", e);
                    throw e;
                }
            }

            configureFilter(filter, filterType, frequency) {
                switch (filterType) {
                    case 'Lowpass':
                        filter.type = 'lowpass';
                        filter.frequency.value = frequency;
                        filter.Q.value = Math.SQRT1_2;
                        break;
                    case 'Highpass':
                        filter.type = 'highpass';
                        filter.frequency.value = frequency;
                        filter.Q.value = Math.SQRT1_2;
                        break;
                    case 'Notch':
                        filter.type = 'peaking';
                        filter.frequency.value = frequency;
                        filter.gain.value = -this.PEAK_EQ_GAIN_DB;
                        filter.Q.value = frequency / (frequency * (Math.pow(2, this.PEAK_EQ_BW_OCT / 2) - Math.pow(2, -this.PEAK_EQ_BW_OCT / 2)));
                        break;
                    case 'Bandpass':
                        filter.type = 'peaking';
                        filter.frequency.value = frequency;
                        filter.gain.value = this.PEAK_EQ_GAIN_DB;
                        filter.Q.value = frequency / (frequency * (Math.pow(2, this.PEAK_EQ_BW_OCT / 2) - Math.pow(2, -this.PEAK_EQ_BW_OCT / 2)));
                        break;
                    default:
                        throw new Error(`Unknown filter type: ${filterType}`);
                }
            }

            async stopCurrentAudio() {
                if (this.currentSourceNode && this.currentSourceNode.context.state === 'running') {
                    try {
                        this.currentSourceNode.stop();
                    } catch (e) {
                        console.warn("Error stopping audio:", e);
                    }
                    this.currentSourceNode = null;
                }
            }

            async playAudioBuffer(audioBuffer) {
                await this.initAudioContext();
                await this.stopCurrentAudio();

                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.audioContext.destination);
                this.currentSourceNode = source;
                source.start();

                return new Promise(resolve => {
                    source.onended = () => {
                        source.disconnect();
                        if (this.currentSourceNode === source) {
                            this.currentSourceNode = null;
                        }
                        resolve();
                    };
                    source.onerror = (e) => {
                        console.error("Audio source error:", e);
                        if (this.currentSourceNode === source) {
                            this.currentSourceNode = null;
                        }
                        resolve();
                    };
                });
            }

            generateQuestion() {
                let filterType, frequency, label, details;

                if (this.useFixedFilter) {
                    filterType = this.fixedFilterType;
                    frequency = this.NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * this.NOTCH_BAND_FREQ_LIST.length)];
                    label = this.NOTCH_BAND_CHOICES[frequency];
                } else {
                    filterType = this.FILTER_TYPES[Math.floor(Math.random() * this.FILTER_TYPES.length)];
                }

                switch (filterType) {
                    case 'Lowpass':
                        frequency = this.LOWPASS_FREQ;
                        label = 'Lowpass';
                        details = `Lowpass Filter (Cutoff: ${this.LOWPASS_FREQ} Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                        break;
                    case 'Highpass':
                        frequency = this.HIGHPASS_FREQ;
                        label = 'Highpass';
                        details = `Highpass Filter (Cutoff: ${this.HIGHPASS_FREQ} Hz, Q: ${Math.SQRT1_2.toFixed(2)})`;
                        break;
                    case 'Notch':
                    case 'Bandpass':
                        if (!this.useFixedFilter) {
                            frequency = this.NOTCH_BAND_FREQ_LIST[Math.floor(Math.random() * this.NOTCH_BAND_FREQ_LIST.length)];
                            label = this.NOTCH_BAND_CHOICES[frequency];
                        } else {
                            label = this.NOTCH_BAND_CHOICES[frequency];
                        }
                        const gain = filterType === 'Notch' ? -this.PEAK_EQ_GAIN_DB : this.PEAK_EQ_GAIN_DB;
                        const calculatedQ = frequency / (frequency * (Math.pow(2, this.PEAK_EQ_BW_OCT / 2) - Math.pow(2, -this.PEAK_EQ_BW_OCT / 2)));
                        details = `${filterType} Filter (Center: ${frequency} Hz (${label}), BW: ${this.PEAK_EQ_BW_OCT} Oct, Gain: ${gain > 0 ? '+' : ''}${gain} dB, Q: ${calculatedQ.toFixed(2)})`;
                        break;
                    default:
                        throw new Error(`Unknown filter type: ${filterType}`);
                }

                const numSamples = Math.floor(this.userDuration * this.FS);
                let originalAudioData;

                if (this.useCustomAudio && this.customAudioBuffer) {
                    const maxStartSample = Math.max(0, this.customAudioBuffer.length - numSamples);
                    const startSample = Math.floor(Math.random() * (maxStartSample + 1));
                    const endSample = Math.min(startSample + numSamples, this.customAudioBuffer.length);
                    originalAudioData = this.customAudioBuffer.getChannelData(0).slice(startSample, endSample);

                    if (originalAudioData.length < numSamples) {
                        const paddedData = new Float32Array(numSamples);
                        paddedData.set(originalAudioData);
                        originalAudioData = paddedData;
                    }
                } else {
                    originalAudioData = this.generatePinkNoise(this.userDuration, this.FS);
                }

                return {
                    filterType, frequency, label, details,
                    originalAudio: originalAudioData,
                    filteredAudio: null
                };
            }

            async startQuiz() {
                await this.initAudioContext();
                await this.stopCurrentAudio();

                this.userDuration = parseFloat(document.getElementById('sampleDuration').value);
                this.showTypeAnswers = document.getElementById('showTypeAnswers').checked;
                this.showDetails = document.getElementById('showDetails').checked;
                this.useCustomAudio = document.querySelector('input[name="audioSource"]:checked').value === 'file';
                this.useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';

                if (this.useFixedFilter) {
                    this.fixedFilterType = document.getElementById('fixedFilterType').value;
                }

                const requiredSamples = Math.floor(this.userDuration * this.FS);
                if (this.useCustomAudio && (!this.customAudioBuffer || this.customAudioBuffer.length < requiredSamples)) {
                    this.showStatus('audioStatus', `Please upload an audio file that is at least ${this.userDuration} seconds long.`, 'error');
                    return;
                }

                this.questions = [];
                this.questionResults = [];
                for (let i = 0; i < this.NUM_QUESTIONS; i++) {
                    this.questions.push(this.generateQuestion());
                }

                this.currentQuestion = 0;
                this.score = 0;

                document.getElementById('setup').classList.add('hidden');
                document.getElementById('quiz').classList.remove('hidden');

                await this.loadQuestion();
            }

            async loadQuestion() {
                const question = this.questions[this.currentQuestion];
                await this.stopCurrentAudio();

                this.resetQuestionUI();
                this.updateQuestionDisplay();
                this.configureQuestionMode();

                this.showStatus('audioStatus', '<div class="loading-spinner"></div>Loading audio...', 'info');
                this.disablePlayButtons(true);

                try {
                    question.filteredAudio = await this.applyFilter(
                        question.originalAudio, 
                        question.filterType, 
                        question.frequency, 
                        this.userDuration
                    );
                    
                    this.hideStatus('audioStatus');
                    this.disablePlayButtons(false);
                } catch (e) {
                    console.error("Failed to render filtered audio:", e);
                    this.showStatus('audioStatus', 'Error generating audio for this question.', 'error');
                    this.showFeedback("Error generating audio for this question. Skipping.", 'incorrect');
                    document.getElementById('nextQuestion').classList.remove('hidden');
                    document.getElementById('guessSection').classList.add('hidden');
                }
            }

            resetQuestionUI() {
                document.getElementById('feedback').classList.add('hidden');
                document.getElementById('nextQuestion').classList.add('hidden');
                document.getElementById('submitAnswer').disabled = true;
                document.getElementById('playSection').classList.remove('hidden');
                document.getElementById('guessSection').classList.remove('hidden');

                this.selectedFilterType = null;
                this.selectedFrequency = null;
                this.clearSelections();
            }

            updateQuestionDisplay() {
                const questionNum = this.currentQuestion + 1;
                document.getElementById('questionNum').textContent = questionNum;
                document.getElementById('questionTitle').textContent = `Question ${questionNum}`;
                document.getElementById('currentScore').textContent = this.score.toFixed(1);
                document.getElementById('progressBar').style.width = `${(this.currentQuestion / this.NUM_QUESTIONS) * 100}%`;
            }

            configureQuestionMode() {
                const question = this.questions[this.currentQuestion];
                
                if (this.useFixedFilter) {
                    document.getElementById('filterTypeSection').classList.add('hidden');
                    document.getElementById('frequencySection').classList.remove('hidden');
                    document.getElementById('focusModeInfo').classList.remove('hidden');
                    document.getElementById('givenFilterType').textContent = question.filterType;
                    this.selectedFilterType = question.filterType;
                } else {
                    document.getElementById('filterTypeSection').classList.remove('hidden');
                    document.getElementById('frequencySection').classList.add('hidden');
                    document.getElementById('focusModeInfo').classList.add('hidden');
                    this.selectedFilterType = null;
                }
            }

            clearSelections() {
                document.querySelectorAll('#filterTypes .btn, #frequencies .btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            disablePlayButtons(disabled) {
                document.querySelectorAll('#playSection button').forEach(btn => {
                    btn.disabled = disabled;
                });
            }

            async playOriginal() {
                const question = this.questions[this.currentQuestion];
                await this.stopCurrentAudio();

                const tempBuffer = this.audioContext.createBuffer(1, question.originalAudio.length, this.FS);
                tempBuffer.getChannelData(0).set(question.originalAudio);
                await this.playAudioBuffer(tempBuffer);
            }

            async playFiltered() {
                const question = this.questions[this.currentQuestion];
                await this.stopCurrentAudio();

                if (question.filteredAudio) {
                    await this.playAudioBuffer(question.filteredAudio);
                } else {
                    console.warn("Filtered audio not yet loaded.");
                }
            }

            selectFilterType(type) {
                this.selectedFilterType = type;
                this.updateButtonSelection('#filterTypes', 'data-type', type);

                if (type === 'Notch' || type === 'Bandpass') {
                    document.getElementById('frequencySection').classList.remove('hidden');
                    this.selectedFrequency = null;
                    this.clearFrequencySelection();
                    document.getElementById('submitAnswer').disabled = true;
                } else {
                    document.getElementById('frequencySection').classList.add('hidden');
                    this.selectedFrequency = null;
                    this.clearFrequencySelection();
                    document.getElementById('submitAnswer').disabled = false;
                }
            }

            selectFrequency(freq) {
                this.selectedFrequency = freq;
                this.updateButtonSelection('#frequencies', 'data-freq', freq.toString());
                document.getElementById('submitAnswer').disabled = false;
            }

            updateButtonSelection(containerSelector, dataAttribute, value) {
                document.querySelectorAll(`${containerSelector} .btn`).forEach(btn => {
                    btn.classList.remove('selected');
                    if (btn.getAttribute(dataAttribute) === value) {
                        btn.classList.add('selected');
                    }
                });
            }

            clearFrequencySelection() {
                document.querySelectorAll('#frequencies .btn').forEach(btn => {
                    btn.classList.remove('selected');
                });
            }

            async submitAnswer() {
                await this.stopCurrentAudio();

                const question = this.questions[this.currentQuestion];
                const result = this.calculateScore(question);
                
                this.score += result.score;
                this.questionResults.push(result);

                document.getElementById('currentScore').textContent = this.score.toFixed(1);
                this.showFeedback(result.feedbackText, result.feedbackClass);
                this.hideQuestionControls();
                document.getElementById('nextQuestion').classList.remove('hidden');
                document.getElementById('progressBar').style.width = `${((this.currentQuestion + 1) / this.NUM_QUESTIONS) * 100}%`;
            }

            calculateScore(question) {
                let questionScore = 0;
                let feedbackClass = 'incorrect';
                let feedbackText = 'Incorrect.';

                const submittedType = this.selectedFilterType;
                const submittedFreq = this.selectedFrequency;

                if (this.useFixedFilter) {
                    if (submittedFreq === question.frequency) {
                        questionScore = 1.0;
                        feedbackClass = 'correct';
                        feedbackText = '‚úÖ Correct frequency!';
                    } else {
                        feedbackClass = 'incorrect';
                        feedbackText = `‚ùå Incorrect frequency. The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                    }
                } else {
                    const correctType = submittedType === question.filterType;

                    if (question.filterType === 'Lowpass' || question.filterType === 'Highpass') {
                        if (correctType) {
                            questionScore = 1.0;
                            feedbackClass = 'correct';
                            feedbackText = `‚úÖ Correct! It was a ${question.filterType} filter.`;
                        } else {
                            feedbackClass = 'incorrect';
                            feedbackText = '‚ùå Incorrect type.';
                        }
                    } else {
                        const correctFreq = submittedFreq === question.frequency;

                        if (correctType && correctFreq) {
                            questionScore = 1.0;
                            feedbackClass = 'correct';
                            feedbackText = `‚úÖ Perfect! It was a ${question.filterType} filter at ${question.frequency} Hz (${question.label}).`;
                        } else if (correctType && !correctFreq) {
                            questionScore = 0.5;
                            feedbackClass = 'partial';
                            feedbackText = `‚ö†Ô∏è Partially Correct. You identified the type '${question.filterType}', but the frequency was incorrect.`;
                        } else {
                            feedbackClass = 'incorrect';
                            feedbackText = '‚ùå Incorrect.';
                        }
                    }
                }

                let fullFeedbackText = feedbackText;

                if (!this.useFixedFilter && this.showTypeAnswers && feedbackClass === 'incorrect') {
                    fullFeedbackText += `<br>The correct filter type was: ${question.filterType}.`;
                }

                if ((question.filterType === 'Notch' || question.filterType === 'Bandpass') && submittedFreq !== question.frequency) {
                    if (this.useFixedFilter || (submittedType === question.filterType) || (!this.useFixedFilter && submittedType !== question.filterType)) {
                        fullFeedbackText += `<br>The correct frequency was: ${question.frequency} Hz (${question.label}).`;
                    }
                }

                if (this.showDetails) {
                    fullFeedbackText += `<br><br><strong>Filter Details:</strong> ${question.details}`;
                }

                return {
                    score: questionScore,
                    feedbackClass,
                    feedbackText: fullFeedbackText,
                    question,
                    submittedType,
                    submittedFreq
                };
            }

            showFeedback(text, className) {
                const feedback = document.getElementById('feedback');
                feedback.innerHTML = text;
                feedback.className = `feedback ${className}`;
                feedback.classList.remove('hidden');
            }

            hideQuestionControls() {
                document.getElementById('playSection').classList.add('hidden');
                document.getElementById('guessSection').classList.add('hidden');
                this.hideStatus('audioStatus');
            }

            async nextQuestion() {
                await this.stopCurrentAudio();
                this.currentQuestion++;

                if (this.currentQuestion < this.NUM_QUESTIONS) {
                    await this.loadQuestion();
                } else {
                    this.endQuiz();
                }
            }

            endQuiz() {
                this.stopCurrentAudio();
                document.getElementById('quiz').classList.add('hidden');
                document.getElementById('results').classList.remove('hidden');
                
                const percentage = (this.score / this.NUM_QUESTIONS) * 100;
                document.getElementById('finalScore').innerHTML = `
                    <div style="font-size: 2em; margin: 20px 0;">
                        ${this.score.toFixed(1)}/${this.NUM_QUESTIONS} (${percentage.toFixed(1)}%)
                    </div>
                `;

                this.showPerformanceAnalysis();
            }

            showPerformanceAnalysis() {
                const analysis = this.analyzePerformance();
                document.getElementById('performanceAnalysis').innerHTML = analysis;
            }

            analyzePerformance() {
                const typeAccuracy = {};
                const freqAccuracy = {};
                
                this.FILTER_TYPES.forEach(type => typeAccuracy[type] = {correct: 0, total: 0});
                this.NOTCH_BAND_FREQ_LIST.forEach(freq => freqAccuracy[freq] = {correct: 0, total: 0});

                this.questionResults.forEach(result => {
                    const {question, submittedType, submittedFreq, score} = result;
                    
                    typeAccuracy[question.filterType].total++;
                    if (submittedType === question.filterType) {
                        typeAccuracy[question.filterType].correct++;
                    }

                    if (question.filterType === 'Notch' || question.filterType === 'Bandpass') {
                        freqAccuracy[question.frequency].total++;
                        if (submittedFreq === question.frequency) {
                            freqAccuracy[question.frequency].correct++;
                        }
                    }
                });

                let analysis = '<div style="text-align: left; margin-top: 20px;"><h3>üìä Performance Analysis</h3>';
                
                analysis += '<h4>Filter Type Accuracy:</h4><ul>';
                Object.entries(typeAccuracy).forEach(([type, data]) => {
                    if (data.total > 0) {
                        const percent = ((data.correct / data.total) * 100).toFixed(0);
                        analysis += `<li>${type}: ${data.correct}/${data.total} (${percent}%)</li>`;
                    }
                });
                analysis += '</ul>';

                const freqData = Object.entries(freqAccuracy).filter(([_, data]) => data.total > 0);
                if (freqData.length > 0) {
                    analysis += '<h4>Frequency Accuracy:</h4><ul>';
                    freqData.forEach(([freq, data]) => {
                        const percent = ((data.correct / data.total) * 100).toFixed(0);
                        const label = this.NOTCH_BAND_CHOICES[freq];
                        analysis += `<li>${freq} Hz (${label}): ${data.correct}/${data.total} (${percent}%)</li>`;
                    });
                    analysis += '</ul>';
                }

                analysis += '</div>';
                return analysis;
            }

            restartQuiz() {
                window.location.reload();
            }

            // Example player methods
            selectExampleFilterType(type) {
                this.exampleSelectedFilterType = type;
                this.exampleSelectedFrequency = null;
                this.exampleOriginalAudioData = null;

                this.updateButtonSelection('#exampleFilterTypes', 'data-type', type);
                document.querySelectorAll('#exampleFrequencies .btn').forEach(btn => btn.classList.remove('selected'));

                if (type === 'Notch' || type === 'Bandpass') {
                    document.getElementById('exampleFrequencySection').classList.remove('hidden');
                    this.updateExamplePlayButtonState();
                } else {
                    document.getElementById('exampleFrequencySection').classList.add('hidden');
                    this.prepareExampleAudio();
                    this.updateExamplePlayButtonState();
                }
                this.hideStatus('exampleStatus');
            }

            selectExampleFrequency(freq) {
                this.exampleSelectedFrequency = freq;
                this.exampleOriginalAudioData = null;

                this.updateButtonSelection('#exampleFrequencies', 'data-freq', freq.toString());
                this.prepareExampleAudio();
                this.updateExamplePlayButtonState();
                this.hideStatus('exampleStatus');
            }

            prepareExampleAudio() {
                const duration = this.userDuration;
                const requiredSamples = Math.floor(duration * this.FS);
                const isFileSource = document.querySelector('input[name="audioSource"]:checked').value === 'file';

                let canGenerate = false;
                if (!isFileSource) {
                    canGenerate = true;
                } else if (this.customAudioBuffer && this.customAudioBuffer.length >= requiredSamples) {
                    canGenerate = true;
                }

                if (canGenerate) {
                    this.exampleOriginalAudioData = this.getExampleOriginalAudioData(duration);
                    if (!this.exampleOriginalAudioData) {
                        console.warn("Failed to prepare example original audio data.");
                    }
                } else {
                    this.exampleOriginalAudioData = null;
                }
            }

            getExampleOriginalAudioData(duration) {
                const numSamples = Math.floor(duration * this.FS);
                const isFileSource = document.querySelector('input[name="audioSource"]:checked').value === 'file';

                if (isFileSource && this.customAudioBuffer) {
                    if (this.customAudioBuffer.length < numSamples) {
                        this.showStatus('exampleStatus', `Uploaded file is too short for ${duration}s duration.`, 'error');
                        return null;
                    }
                    const maxStartSample = Math.max(0, this.customAudioBuffer.length - numSamples);
                    const startSample = Math.floor(Math.random() * (maxStartSample + 1));
                    const endSample = Math.min(startSample + numSamples, this.customAudioBuffer.length);

                    let originalData = this.customAudioBuffer.getChannelData(0).slice(startSample, endSample);

                    if (originalData.length < numSamples) {
                        const paddedData = new Float32Array(numSamples);
                        paddedData.set(originalData);
                        originalData = paddedData;
                    }
                    return originalData;
                } else if (!isFileSource) {
                    return this.generatePinkNoise(duration, this.FS);
                } else {
                    this.showStatus('exampleStatus', 'Please upload an audio file first.', 'error');
                    return null;
                }
            }

            async playExampleOriginal() {
                if (!this.exampleOriginalAudioData) {
                    this.showStatus('exampleStatus', 'Audio source data not ready.', 'error');
                    return;
                }

                const duration = this.userDuration;
                const numSamples = Math.floor(duration * this.FS);

                await this.initAudioContext();
                const tempBuffer = this.audioContext.createBuffer(1, numSamples, this.FS);
                tempBuffer.getChannelData(0).set(this.exampleOriginalAudioData.slice(0, numSamples));

                this.showStatus('exampleStatus', 'Playing original...', 'info');

                try {
                    await this.playAudioBuffer(tempBuffer);
                    this.showStatus('exampleStatus', 'Done.', 'success', 1000);
                } catch (e) {
                    console.error("Error playing example original:", e);
                    this.showStatus('exampleStatus', 'Error playing original audio.', 'error');
                } finally {
                    this.updateExamplePlayButtonState();
                }
            }

            async playExampleFiltered() {
                const type = this.exampleSelectedFilterType;
                const freq = this.exampleSelectedFrequency;
                const duration = this.userDuration;

                if (!type) {
                    this.showStatus('exampleStatus', 'Please select a filter type.', 'error');
                    return;
                }
                if ((type === 'Notch' || type === 'Bandpass') && freq === null) {
                    this.showStatus('exampleStatus', 'Please select a center frequency.', 'error');
                    return;
                }
                if (!this.exampleOriginalAudioData) {
                    this.showStatus('exampleStatus', 'Audio source data not ready.', 'error');
                    return;
                }

                document.getElementById('playExampleFiltered').disabled = true;
                this.showStatus('exampleStatus', '<div class="loading-spinner"></div>Generating filtered audio...', 'info');

                try {
                    const filterFreq = freq || (type === 'Lowpass' ? this.LOWPASS_FREQ : this.HIGHPASS_FREQ);
                    const filteredAudioBuffer = await this.applyFilter(this.exampleOriginalAudioData, type, filterFreq, duration);

                    this.showStatus('exampleStatus', 'Playing filtered...', 'info');
                    await this.playAudioBuffer(filteredAudioBuffer);
                    this.showStatus('exampleStatus', 'Done.', 'success', 1000);
                } catch (e) {
                    console.error("Error playing example filtered:", e);
                    this.showStatus('exampleStatus', 'Error playing filtered audio.', 'error');
                } finally {
                    this.updateExamplePlayButtonState();
                }
            }

            updateExamplePlayButtonState() {
                const playFilteredButton = document.getElementById('playExampleFiltered');
                const playOriginalButton = document.getElementById('playExampleOriginal');

                let canPlayFiltered = false;
                if (this.exampleSelectedFilterType !== null) {
                    if (this.exampleSelectedFilterType === 'Notch' || this.exampleSelectedFilterType === 'Bandpass') {
                        if (this.exampleSelectedFrequency !== null && this.exampleOriginalAudioData !== null) {
                            canPlayFiltered = true;
                        }
                    } else {
                        if (this.exampleOriginalAudioData !== null) {
                            canPlayFiltered = true;
                        }
                    }
                }

                const canPlayOriginal = this.exampleOriginalAudioData !== null;

                playFilteredButton.disabled = !canPlayFiltered;
                playOriginalButton.disabled = !canPlayOriginal;

                const isFileSource = document.querySelector('input[name="audioSource"]:checked').value === 'file';
                document.getElementById('exampleAudioSource').textContent = isFileSource ? 
                    (this.customAudioBuffer ? 'Uploaded File' : 'Uploaded File (Not loaded)') : 'Pink Noise';
                document.getElementById('exampleDuration').textContent = this.userDuration;
            }

            // Event handlers
            onDurationChange() {
                const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
                this.userDuration = selectedDuration;
                document.getElementById('requiredDuration').textContent = selectedDuration;
                document.getElementById('exampleDuration').textContent = selectedDuration;

                if (document.querySelector('input[name="audioSource"]:checked').value === 'file') {
                    const fileInput = document.getElementById('audioFile');
                    if (fileInput.files && fileInput.files.length > 0) {
                        this.handleAudioFile();
                    } else {
                        const requiredSamples = Math.floor(selectedDuration * this.FS);
                        document.getElementById('startButton').disabled = (!this.customAudioBuffer || this.customAudioBuffer.length < requiredSamples);
                        this.prepareExampleAudio();
                        this.updateExamplePlayButtonState();
                    }
                } else {
                    document.getElementById('startButton').disabled = false;
                    this.prepareExampleAudio();
                    this.updateExamplePlayButtonState();
                }
            }

            onAudioSourceChange() {
                this.useCustomAudio = document.querySelector('input[name="audioSource"]:checked').value === 'file';
                const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
                const requiredSamples = Math.floor(selectedDuration * this.FS);

                if (this.useCustomAudio) {
                    document.getElementById('fileSection').classList.remove('hidden');
                    document.getElementById('startButton').disabled = !this.customAudioBuffer || this.customAudioBuffer.length < requiredSamples;
                } else {
                    document.getElementById('fileSection').classList.add('hidden');
                    this.hideStatus('fileStatus');
                    document.getElementById('startButton').disabled = false;
                }

                this.prepareExampleAudio();
                this.updateExamplePlayButtonState();
                const isFileSource = this.useCustomAudio;
                document.getElementById('exampleAudioSource').textContent = isFileSource ? 
                    (this.customAudioBuffer ? 'Uploaded File' : 'Uploaded File (Not loaded)') : 'Pink Noise';
            }

            onFilterModeChange() {
                this.useFixedFilter = document.querySelector('input[name="filterMode"]:checked').value === 'fixed';
                if (this.useFixedFilter) {
                    document.getElementById('fixedFilterSection').classList.remove('hidden');
                    this.fixedFilterType = document.getElementById('fixedFilterType').value;
                    document.getElementById('filterTypeDisplay').textContent = this.fixedFilterType;
                } else {
                    document.getElementById('fixedFilterSection').classList.add('hidden');
                    this.fixedFilterType = null;
                }
            }

            onFixedFilterTypeChange() {
                this.fixedFilterType = document.getElementById('fixedFilterType').value;
                document.getElementById('filterTypeDisplay').textContent = this.fixedFilterType;
            }

            async handleAudioFile() {
                const fileInput = document.getElementById('audioFile');
                const file = fileInput.files[0];
                const startButton = document.getElementById('startButton');

                const selectedDuration = parseFloat(document.getElementById('sampleDuration').value);
                const requiredSamples = Math.floor(selectedDuration * this.FS);

                this.hideStatus('fileStatus');
                this.customAudioBuffer = null;
                startButton.disabled = true;

                this.exampleOriginalAudioData = null;
                this.updateExamplePlayButtonState();
                document.getElementById('exampleAudioSource').textContent = 'Uploaded File (Loading...)';
                this.showStatus('exampleStatus', '<div class="loading-spinner"></div>Decoding...', 'info');

                if (!file) {
                    this.updateExamplePlayButtonState();
                    document.getElementById('exampleAudioSource').textContent = 'Uploaded File (No file)';
                    this.hideStatus('exampleStatus');
                    return;
                }

                await this.initAudioContext();

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const originalBuffer = await this.audioContext.decodeAudioData(e.target.result);
                        const numberOfChannels = originalBuffer.numberOfChannels;
                        const durationInSeconds = originalBuffer.duration;
                        const resampledLength = Math.floor(durationInSeconds * this.FS);

                        const offlineContext = new OfflineAudioContext(numberOfChannels, resampledLength, this.FS);
                        const source = offlineContext.createBufferSource();
                        source.buffer = originalBuffer;
                        source.connect(offlineContext.destination);
                        source.start();

                        this.showStatus('exampleStatus', '<div class="loading-spinner"></div>Resampling...', 'info');
                        const resampledBuffer = await offlineContext.startRendering();

                        if (resampledBuffer.numberOfChannels > 1) {
                            const monoBuffer = this.audioContext.createBuffer(1, resampledBuffer.length, this.FS);
                            monoBuffer.getChannelData(0).set(resampledBuffer.getChannelData(0));
                            this.customAudioBuffer = monoBuffer;
                        } else {
                            this.customAudioBuffer = resampledBuffer;
                        }

                        if (this.customAudioBuffer.length < requiredSamples) {
                            this.showStatus('fileStatus', 
                                `File is too short for ${selectedDuration} seconds after resampling (${(this.customAudioBuffer.duration).toFixed(2)}s @ ${this.FS} Hz). Please select a longer file.`, 
                                'error'
                            );
                            startButton.disabled = true;
                            this.customAudioBuffer = null;
                        } else {
                            this.showStatus('fileStatus', 
                                `‚úÖ File loaded successfully! Duration: ${(this.customAudioBuffer.duration).toFixed(2)}s (Original: ${originalBuffer.sampleRate} Hz)`, 
                                'success'
                            );
                            startButton.disabled = false;
                        }

                        this.prepareExampleAudio();
                        this.updateExamplePlayButtonState();
                        this.hideStatus('exampleStatus');
                    } catch (error) {
                        console.error("Error processing audio file:", error);
                        this.showStatus('fileStatus', `Error processing audio file: ${error.message}`, 'error');
                        startButton.disabled = true;
                        this.customAudioBuffer = null;
                        this.prepareExampleAudio();
                        this.updateExamplePlayButtonState();
                        this.hideStatus('exampleStatus');
                    }
                };

                reader.onerror = (e) => {
                    console.error("Error reading audio file:", e);
                    this.showStatus('fileStatus', "Error reading audio file.", 'error');
                    startButton.disabled = true;
                    this.customAudioBuffer = null;
                    this.prepareExampleAudio();
                    this.updateExamplePlayButtonState();
                    this.hideStatus('exampleStatus');
                };

                reader.readAsArrayBuffer(file);
            }

            updateUI() {
                document.getElementById('requiredDuration').textContent = this.userDuration;
                document.getElementById('exampleDuration').textContent = this.userDuration;
                this.onAudioSourceChange();
                this.onFilterModeChange();
                document.getElementById('filterTypeDisplay').textContent = document.getElementById('fixedFilterType').value;
                this.selectExampleFilterType(null);
                this.prepareExampleAudio();
                this.updateExamplePlayButtonState();
            }
        }

        // Initialize the quiz when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new HearingTestQuiz();
        });
    </script>
</body>
</html>